% $Author: ducasse $
% $Date: 2009-08-24 10:17:33 +0200 (Mon, 24 Aug 2009) $
% $Revision: 28563 $

% 2011-08-23 - Memento addition Stef chating with dale at ESUG.
% 2011-09-11 - Migrated to PharoBox: svn checkout https://XXX@scm.gforge.inria.fr/svn/pharobooks/PharoByExampleTwo-Eng

%% todo: Stef should go over all the text with the memento in mind and verify all the snippets and stress the right usage in the text


%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
       \documentclass[a4paper,10pt,twoside]{book}
       \usepackage[
              papersize={6.13in,9.21in},
              hmargin={.75in,.75in},
              vmargin={.75in,1in},
              ignoreheadfoot
       ]{geometry}
       \input{../common.tex}
       \setboolean{lulu}{true}
% --------------------------------------------
% A4:
%       \documentclass[a4paper,11pt,twoside]{book}
%       \input{../common.tex}
%       \usepackage{a4wide}
% --------------------------------------------
     \graphicspath{{figures/} {../figures/}}
       \begin{document}
\fi
%=================================================================
%\renewmessage{\nnbb}[2]{} % Disable editorial comments
\sloppy

%=================================================================
%\renewcommand{\nnbb}[2]{#2} % Disable editorial comments


\chapter{Managing projects with Metacello}
\chalabel{metacello}
\chapterauthor{\authordale{} \\ \authormariano{}}

\noindent
Have you ever had this problem when trying to load a project: you get an error because a package that you were not even aware of is missing?  Or worse\,---\,it is present, but you have the wrong version? This situation can easily occur, even though the project loads fine for its developers, when the developers are working in a context that is different from yours. 

The solution is for the project developers to use a \emph{package management system} to explicitly manage the dependencies between the packages that make up a project.  
This chapter shows you how to use Metacello, Pharo's package management system, and the benefits of using it. 

\section{Introduction}

We say that Metacello is a \emph{package management system} for Monticello. 
But what, exactly, does that mean?
A package management system is a collection of tools that automate the process of installing, upgrading, configuring, and removing \emph{sets} of software packages. Metacello groups packages to simplify things for the user, and manages dependencies, \ie which versions of what components should be loaded to make sure that the whole set of packages is coherent. 

A package management system provides a consistent way to install packages. 
Indeed, package management systems are sometimes incorrectly referred to as installers. This can lead to confusion, because a package management system does a lot more than install software.  You may have used package management systems in other contexts: examples include Envy (in VisualAge Smalltalk), Maven (in Java), and apt-get/aptitude (in Debian and Ubuntu).

One of the key features of a package management system is that it should \emph{correctly load any package}: you should never need to manually install anything.  To make this possible, each dependency, and the dependencies of the dependencies, and so on, must be specified in the description of the package, with enough information to allow the package management tools to load them in the correct order. 

As an example of the power of Metacello, you can take a PharoCore image, and load {\em any} package of {\em any} project without any problems with dependencies. Of course, Metacello does not do magic: this works only so long as the package developers have defined the dependencies properly.

% The software is often downloaded from a number of software repositories. It is also common to have a central repository where all the software is submitted but this is totally orthogonal issue.

\section{One tool for each job}

Pharo provides three tools for managing software packages; they are closely related, but each has its own purpose. The tools are Monticello, which manages versions of source code, Gofer, which is a scripting interface for Monticello, and Metacello, which is a package management system.
% it might make sense to talk about Monticello as a Source Code Management system or SCM here? %


%As a principle, we have to know that we need {\em a tool for each job}. A tool cannot do everything. Each tool satisfies a limited amount of problems and it will probably delegate to another tool to do certain tasks. If you read the first Pharo By Example book you may noticed that this concept is quite similar to Object-Oriented Design: we don't want to have only one object that does everything and we rather to have multiple objects where each object has certain behavior and they collaborate together to do a specific task. 
%So we have 

\begin{description}

\item{\textbf{Monticello: source code versioning.}}
Source code versioning is the process of assigning unique version names numbers to particular software states.  It is also called revision control.  
In particular, source code versioning incrementally keeps track of different versions, also known as revisions, of ``pieces of software''. 
In object-oriented programming, these ``pieces of software'' are methods, classes or packages. A source code versioning system lets you commit a new version, update to a new version committed by someone else, merge changes, look at the differences between versions, and revert to an older version. 

Pharo uses the Monticello source code versioning system, which manages Monticello packages.  Monticello lets us do all of the above operations on individual packages, but Monticello does not provide a good way to easily specify dependencies \emph{between} packages, identify stable versions of a package, or group packages into meaningful units.  

\item {\textbf{Gofer: Monticello's scripting interface.}}
Gofer is a small tool that sits on top of Monticello: it is used to load, update, merge, difference, revert, commit, recompile and unload groups of Monticello packages. Gofer also makes sure that these operations are performed as cleanly as possible. 
For more information, see \charef{gofer}.

\item{\textbf{Metacello: package management.}} Metacello introduces the notion of a project as a set of related Monticello packages, and is used to manage projects,   their dependencies, and their metadata. 
Metacello also manages dependencies between packages.
\end{description}




\section{Metacello features}

Metacello is consistent with the important features of Monticello. It is based on the following ideas.

\begin{description}
\item[\textit{Declarative project descriptions.}] A Metacello project has named versions consisting of lists of Monticello package \emph{versions}. Dependencies are explicitly expressed in terms of named versions of required projects. A \emph{required project} is a reference to another Metacello project.  Collectively, all of these descriptions are called the project metadata.

\item[\textit{Project metadata are versioned}] Metacello project metadata are represented as instance methods in a class.  This means that Metacello project metadata can themselves be stored as a Monticello package, and are thus subject to version control.  
% As a result, it is easy for distributed groups of developers to collaborate on ad-hoc projects.
% apb --- this doesn't seem like a result to me!  Whether the distributed group can collaborate easily seems to depend on a lot more, like, do they share the same values and goals, speak the same language ...
As a result,
concurrent updates to the project metadata can be managed easily: parallel versions of the metadata can be merged just like parallel versions of the code base itself. 

%\ab{These last two ideas seem like the same idea to me.  But there is an important idea --- that project descriptions should themselves be under version control --- that shows through only implicitly.  Maybe this section should be refactored?}
% So: I refactored it.  Does it make sense to you?  Is there a third idea that's missing?

\end{description}

Metacello has the following features:

\begin{itemize}
\item Cross-platform operation: Metacello  runs on all platforms that support Monticello, which currently means Pharo, Squeak and GLASS.

\item Conditional package loading: to enable projects to run on multiple platforms, Metacello supports conditional loading of platform-specific Monticello packages. 

\item Configurations: Metacello actually manages not projects but \emph{configurations of projects}.  This is because large projects frequently have multiple variants: there might be a configuration for Pharo and another configuration for Squeak, which might have different prerequisites.  Moreover, there might be stable, released configurations as well as experimental configurations that have cool new features but also more bugs.

\ab{Please correct the above; I found that something needed to be said about configurations before we start using the term.}

\end{itemize}


\section{A Simple Case Study}

Let's start using Metacello to manage a software project called \emph{CoolBrowser}. The first step is to create a Metacello configuration for the project by simply copying the class \ct{MetacelloConfigTemplate} and naming it \ct{ConfigurationOfCoolBrowser}.  

By convention, the name of a Metacello configuration is constructed by prefixing the name of the project with \ct{'ConfigurationOf'}. 
To do this, find class \ct{MetacelloConfigTemplate} in the system browser, right click on the class name, and select the option \menu{copy}. 

This is the class definition:
\begin{code}{}
Object subclass: #ConfigurationOfCoolBrowser
       instanceVariableNames: 'project'
       classVariableNames: 'LastVersionLoad'
       poolDictionaries: "
       category: 'Metacello-MC-Model'
\end{code}

You will notice that \ct{ConfigurationOfCoolBrowser} has some instance- and class-side methods; we will explain later how they are used. Notice also that this class inherits from \ct{Object}.  This is deliberate: it's important that Metacello configurations can be loaded without any prerequisites, including Metacello itself, so Metacello configurations cannot rely on a common superclass.

\ab{Should these be called configuration methods?  Are versions different from or the same as configurations?  If they are different, then we need to explain the difference; if they are the same, then we should pick one term and use it.}

Now imagine that the project \ct{CoolBrowser} has several versions, for example, 1.0, 1.0.1, 1.4, and 1.67. 
With Metacello you create an instance-side method that describes the contents of each version of the project. Method names for version methods are unimportant as long as the method is annotated with the \ct{<version: >} pragma, as shown below.  However, there is a  convention that  version methods are named \ct{versionXXX:}, where \ct{XXX} is the version number with illegal characters (like '.') removed.

Suppose for the moment that the project \ct{CoolBrowser} contains two packages: \ct{CoolBrowser-Core} and \ct{CoolBrowser-Tests}. 
A version method might look like this:

\begin{code}{}
ConfigurationOfCoolBrowser>>version01: spec 
       <version: '0.1'>
       
       spec for: #common do: [
              spec repository: 'http://www.example.com/CoolBrowser'.
              spec 
                     package: 'CoolBrowser-Core' with: 'CoolBrowser-Core-MichaelJones.10';
                     package: 'CoolBrowser-Tests' with: 'CoolBrowser-Tests-JohnLewis.3' ]
\end{code}

\noindent
There are a lot of things that we need to explain in this code!

\begin{itemize}
\item Immediately after the method selector you see the pragma definition:  \ct{ <version: '0.1'>}. The pragma indicates that the version created in this method should be associated with version \ct{0.1} of the CoolBrowser project. That's why we said that the name of the method is not that important. Metacello uses the pragma, not the method name, to identify the version being defined.

\item Looking a little closer, you see that the argument to the method, \ct{spec}, is the only variable in
the method and it is used as the receiver of four different messages:    \ct{for:do:},    \ct{package:with:},  \ct{file:}  and  \ct{repository:}.

\item Each time a block expression is executed a new object is pushed on a stack and the messages within the block are sent to the object on the top of the stack.
\ab{I've no idea what this means.}

\item The symbol \ct{#common} indicates that this project version is common to all platforms.  In addition to \ct{#common}, there are pre-defined attributes for each of the platforms on which Metacello runs (\ct{#pharo}, \ct{#squeak}, \ct{#gemstone} and \ct{#squeakCommon}). 
We will describe this feature later in the chapter. 
\end{itemize}

The  method \ct{version01: spec} builds a description of version \ct{0.1} of the package in the object \ct{spec}.
The common code for version \ct{0.1} (specified using the message \ct{for: #common do:}) consists of particular versions of the packages named \ct{'CoolBrowser-Core'} and \ct{'CoolBrowser-Tests'}.
These are specified with the message \ct{package:} \emph{packageName} \ct{with:} \emph{versionName}.
These versions are available in the Monticello repository \ct{'http://www.example.com/CoolBrowser'}, which is specified using the message \ct{repository:}.

Sometimes, a Monticello repository requires a username and password. In such case the following message can be used:

\begin{code}{}
         spec repository: 'http://www.example.com/private' username: 'foo' password: 'bar' 
\end{code}

\ab{Leave the above until later?  Or to a reference section?}

How can we reify the specification of version \ct{0.1}?
We do so by evaluating the following expression: 

\begin{code}{}
         (ConfigurationOfCoolBrowser project version: '0.1') spec
\end{code}

This will answer an object (of class \ct{MetacelloMCVersionSpec}) that contains exactly the information in the method that defines version '0.1'.

\ab{Somewhere we need to explain the difference between a version and a version spec.  I don't know why we have both visible.}

\ab{At this point, I'm also a bit confused by the nomenclature.  The Class ``ConfigurationOfCoolBrowser'' seems to define ALL of the possible CoolBrowsers, so it really represents the project, not a particular configuration of the project.  Of course, we then get teh normal class-instance dichotomy, so an Instance of ConfigurationOfCoolBrowser does indeed describe a single configuration (called a version??)}

\begin{figure}
\begin{center}
\includegraphics[width=0.6\linewidth]{version01}
\caption{Simple version.}
\end{center}
\end{figure}

\paragraph{Creating a new version.}
Let us assume that version \ct{0.2} of our project consists of the package versions \ct{'CoolBrowser-Core-MichaelJones.15'} and \mbox{\ct{'CoolBrowser-Tests-JohnLewis.8'}} and a new package \ct{'CoolBrowser-Addons'} with version \ct{'CoolBrowser-Addons-JohnLewis.3'}. 
We can specify this by creating the following method named \ct{version02:}.

\begin{code}{}
ConfigurationOfCoolBrowser>>version02: spec 
      <version: '0.2'>
       
      spec for: #common do: [
            spec repository: 'http://www.example.com/CoolBrowser'.
            spec 
                  package: 'CoolBrowser-Core' with: 'CoolBrowser-Core-MichaelJones.15';
                  package: 'CoolBrowser-Tests' with: 'CoolBrowser-Tests-JohnLewis.8';
                  package: 'CoolBrowser-Addons' with: 'CoolBrowser-Addons-JohnLewis.3']
\end{code}
 
\begin{figure}
\begin{center}
\includegraphics[width=0.6\linewidth]{version02}
\caption{Two versions of a project.}
\end{center}
\end{figure} 
 

\section{Naming your Configuration}

In the previous section, we learned that we have to create a class for our configuration. 
It is not necessary to name this class with a particular name. Nevertheless there is a convention that we recommend you follow:  name the class \ct{ConfigurationOfXXX} where \ct{XXX} is your project. In our example, it is \ct{ConfigurationOfCoolBrowser}.

There is also a convention to create a Monticello package with the same name as the configuration class, and to put the class in that package. So in this example you will create a package \ct{ConfigurationOfCoolBrowser} containing exactly one class, \ct{ConfigurationOfCoolBrowser}. 

By making the package name and the configuration class name the same, and by starting them with the string \ct{ConfigurationOf},  we make it easy to scan through a repository listing the available projects. It is also very convenient to have the configurations stored in their own Monticello repository. That is why the repositories \ct{http://www.squeaksource.com/Pharo10MetacelloRepository} and \ct{http://www.squeaksource.com/Pharo11MetacelloRepository} exist: they contain the configurations of various tools and applications, making them easy to find. 

%Having all configurations in the same place has several advantages:
%\begin{itemize}
%\item Finding the configuration package is easier in the Monticello browser package list.
%\item Do not have any conflict with Monticello package naming (for example, you can have the %CoolBrowser package and this might conflict with the CoolBrowserConfiguration).
%\item When you have to manage multiple Configurations in the PackageBrowser.
%\item Given that the name is slightly counter intuitive, it also has very few chances to %collide with other names.
%\end{itemize}

As a general practice, we suggest that initially you save the Configuration package in your working project. When you decide it is ready for release, you can copy it into the MetacelloRepository. A process for publishing configurations in specific distribution repositories is currently being defined.



\subsection{Loading a Metacello Configuration}
Of course, the point of specifying project configurations in Metacello is to be able to load exactly that configuration into your image, and thus to be sure that you have a coherent set of package versions. Here are some examples for loading versions of the CoolBrowser project. 

If you print the result of each expression, you will see a list of packages \emph{in load order}: Metacello manages not only which packages are loaded, but also the order. 

\begin{code}{}
  (ConfigurationOfCoolBrowser project version: '0.1') load.
  (ConfigurationOfCoolBrowser project version: '0.2') load.
\end{code}

\ab{The text seems first to imply first that these expressions return values (``a list of packages'') and then that they have an effect (``loads the packages'').  Do they do both?}
  
Note that in each case, all of the packages associated with the version are loaded\,---\,this  
is the default behavior. If you want to load a subset of the packages in a project, you should list 
the names of the packages that you are interested in as an argument to the \ct{load:} method:

\begin{code}{}
  (ConfigurationOfCoolBrowser project version: '0.2') load: { 
  		'CoolBrowser-Core' 
		'CoolBrowser-Addons' }.
\end{code}

\ab{This seems really arcane.  Need it be mentioned here?  Can't it be deferred to a reference section?}

Note that if you want to load simulate the loading of a configuration, but not to actually load it, you should use \ct{record:} instead of \ct{load:}

\ab{What on earth does that mean?}

\begin{code}{}
  (ConfigurationOfCoolBrowser project version: '0.2') record: {
  		 'CoolBrowser-Core' 
		 'CoolBrowser-Addons' }.
\end{code}

But instead of doing a "do it", do a "print it", send it the message loadDirective.
\ab{Eh?  I'm lost.  What is the point here?}

\begin{code}{}
  ((ConfigurationOfCoolBrowser project version: '0.2') record: { 
  		'CoolBrowser-Core' 
		'CoolBrowser-Addons' }) loadDirective.
\end{code} loadDirective.


\section{Managing dependencies between packages}

A project is generally composed of several packages, which often have dependencies on other packages.  It is also likely that a certain package depends on a specific version of another package. Handling dependencies correctly is really important and  is one of the major benefits of Metacello. 

There are two types of dependencies:
\begin{itemize}
\item Internal dependencies: there are several packages inside a project; some of them depend on other packages in the same project. 
\item Dependencies between projects: it is common for a project to depend on another project, or on some packages from another project. 
For example, Pier (a meta-described content management system depends on Magritte (a metadata modeling framework) and Seaside (a framework for web application development).
\end{itemize}

For now we will focus on the first case: internal dependencies.  In our example, imagine that the packages \ct{CoolBrowser-Tests} and \ct{CoolBrowser-Addons} both depend on \ct{CoolBrowser-Core}. 
The specifications for versions \ct{0.1} and \ct{0.2} did not capture this dependency.  Here is a new configuration that does:

\begin{code}{}
ConfigurationOfCoolBrowser>>version03: spec 
       <version: '0.3'>
       
       spec for: #common do: [
              spec repository: 'http://www.example.com/CoolBrowser'.
              spec 
                     package: 'CoolBrowser-Core' with: 'CoolBrowser-Core-MichaelJones.15';
                     package: 'CoolBrowser-Tests' with: [
                            spec 
                                   file: 'CoolBrowser-Tests-JohnLewis.8';
                                   !\textbf{requires:}! 'CoolBrowser-Core' ];
                     package: 'CoolBrowser-Addons' with: [
                            spec 
                                   file: 'CoolBrowser-Addons-JohnLewis.3';
                                   !\textbf{requires:}! 'CoolBrowser-Core' ]].
\end{code}

\noindent
This version is depicted in \figref{version03}.

\ab{This diagram doesn't help me.  I think that I need to see a graph structure representing the configuration, its components, and the dependencies between them.  The Syntax of the DSL will get me only so far: I need a MODEL on which to hang the ideas.  I've been struggling \emph{not} to build my own (incorrect) model up to this point, while waiting for the text to give me one, but I can't hold any more ideas in my head without a model.}

In \ct{version03:} we've added dependency information using the \ct{requires:} directive.

\ab{We have also introduced the file message, without saying anything about what it means.  What have \emph{files} got to do with any of this?}
Both \ct{CoolBrowser-Tests} and  \ct{CoolBrowser-Addons} require \ct{CoolBrowser-Core}, which must be loaded before they are loaded. 
Notice that we did not specify the exact version of \ct{Cool-Browser-Core} on which they depend.  This can cause problems\,---\,but don't worry, we'll address this deficiency soon!.

\begin{figure}
\begin{center}
\includegraphics[width=0.6\linewidth]{version03}
\caption{Version \ct{0.3} expresses internal dependencies between packages in the same project.\label{fig:version03}}
\end{center}
\end{figure} 


With this version we are mixing structural information (required packages and repository) with version information. 
We can expect that, over time, the version information will change while the structural information will remain more or less the same. 
To capture this, Metacello introduces the concept of \emph{Baselines}.


\section{Baselines}
A baseline is a concept from Software Configuration Management. 
A baseline is a well-defined, well-documented reference that serves as the foundation for other activities. Generally, a baseline may be a distributed work product \ab{eh?}, or conflicting work products \ab{eh?} that can be used as a logical basis for comparison \ab{of what?}

In Metacello, a baseline represents the skeleton of a project in terms of the structural dependencies between packages or projects. A baseline defines the structure of a project using just package names. When the structure changes, the baseline should be updated. In the absence of structural changes, the changes are limited to picking specific versions of the packages in the baseline.

Now, let's continue with our example. First we modify it to use baselines: we create one method per baseline. \sd{is the \lct{blessing: \#{}baseline} line important? If so we should say it what it means!}

\needspace{17ex}
\begin{code}{}
ConfigurationOfCoolBrowser>>baseline04: spec 
       <version: '0.4-baseline'>
       
       spec for: #common do: [
              spec blessing: #baseline.
              spec repository: 'http://www.example.com/CoolBrowser'.
              
              spec 
                     package: 'CoolBrowser-Core';
                     package: 'CoolBrowser-Tests' with: [ spec requires: 'CoolBrowser-Core' ];
                     package: 'CoolBrowser-Addons' with: [ spec requires: 'CoolBrowser-Core' ] ].

\end{code}

The method \ct{baseline04:} defines the structure of version \ct{'0.4-baseline'},
which will be used by several versions.  For example, the version \ct{'0.4'} defined below refers to it, as shown in \figref{version04}.  The baseline specifies a repository, the packages, and the  dependencies between those packages, but it does not specify the specific versions of the packages.  We'll cover the \ct{blessing:} message  later.

\begin{figure}
\begin{center}
\includegraphics[width=0.6\linewidth]{version04}
\caption{Version 0.4 now imports a baseline that expresses the dependencies between packages.\label{fig:version04}}
\end{center}
\end{figure} 

To define a version in terms of a baseline, we use the pragma \mbox{\ct{<version:imports:>}}, as follows:

\begin{code}{}
ConfigurationOfCoolBrowser>>version04: spec 
       <version: '0.4' imports: #('0.4-baseline')>
       
       spec for: #common do: [
              spec 
                     package: 'CoolBrowser-Core' with: 'CoolBrowser-Core-MichaelJones.15';
                     package: 'CoolBrowser-Tests' with: 'CoolBrowser-Tests-JohnLewis.8';
                     package: 'CoolBrowser-Addons' with: 'CoolBrowser-Addons-JohnLewis.3' ].
\end{code}


In the method \ct{version04:}, we specify the specific versions of the packages. The pragma \ct{version:imports:} specifies the list of versions that this version (version '0.4') is based upon. In fact, if you print the spec for '0.4-baseline' and then print the spec for '0.4' you will see that '0.4' is a composition of both versions.
\ab{The above text says something about the relationship between three objects.  However, we have only two objects in hand.  I'm confused.}

Once a specific version is specified, it is loaded in the same way, regardless of the fact that it uses a baseline.
\begin{code}{}
(ConfigurationOfCoolBrowser project version: '0.4') load.
\end{code}

\paragraph{Loading Baselines.}
Even though version \ct{'0.4-baseline'} does not contain explicit package version information, you can still load it!   
\begin{code}{}
(ConfigurationOfCoolBrowser project version: '0.4-baseline') load.
\end{code}
\noindent
When the loader encounters a package without version information, it attempts to load the most-recent version of the package from the repository.

Sometimes, especially when several developers are working on a project, it may be useful to load a \ct{baseline} version to access the most-recent work of all of the developers.  So, contrary to what the name suggests, the \ct{baseline} version is really the ``bleeding edge'' version.

\paragraph{Specifying a new version.}
Now suppose that we want to create a new version of our project, version \ct{'0.5'}, that has the same structure as version \ct{'0.4'}, but contains different  versions of the packages.  We can capture this intent by importing the same baseline; this relationship is depicted in Figure~\figref{version05}.

\ab{The above text says that version 0.5 depends in some way on version 0.4.  The diagram in \figref{version05} says that version04 depends on version05, that is, the opposite.  However, the code below doesn't say anything about a dependency on version04, only on 0.4-baseline.}

\begin{code}{} 
ConfigurationOfCoolBrowser>>version05: spec 
       <!\textbf{version: '0.5' imports: \#('0.4-baseline')}>!
       
      spec for: #common do: [
            spec 
                  package: 'CoolBrowser-Core' with: 'CoolBrowser-Core-MichaelJones.20';
                  package: 'CoolBrowser-Tests' with: 'CoolBrowser-Tests-JohnLewis.8';
                  package: 'CoolBrowser-Addons' with: 'CoolBrowser-Addons-JohnLewis.6' ].
\end{code}

\begin{figure}
\begin{center}
\includegraphics[width=0.6\linewidth]{version05}
\caption{A second version (0.5) imports the same baseline.}\label{fig:version05}
\end{center}
\end{figure} 

Creating a baseline for a big project will often require some time and effort, since it must capture all the dependencies of all the packages, as well as some other things that we will look at later.
However, once the baseline is defined, creating new versions of the project is greatly simplified and takes very little time. 

\section{Groups}
Suppose that now that as the CoolBrowser project grows, a developer writes some tests for \ct{CoolBrowser-Addons}.  These constitute a new package named \ct{'CoolBrowser-AddonsTests'}, which naturally depends on \ct{'CoolBrowser-Addons'} and \ct{'CoolBrowser-Tests'}, as shown in \figref{version06}.

We may want to load projects with or without tests. In addition, it would be convenient to be able to load all of the tests with a simple expression like:

\begin{code}{}
(ConfigurationOfCoolBrowser project version: '0.6') load: 'Tests'.
\end{code}

instead of having to explicitly list all of the test packages, like this:
 
\begin{code}{} 
(ConfigurationOfCoolBrowser project version: '0.6') 
       load: #('CoolBrowser-Tests' 'CoolBrowser-AddonsTests').
\end{code}
 
To make this possible, Metacello provides the notion of \emph{group}. 
A group is a collection of items; each item may be a package, a projects, or even another group.  In this example, we create a group called \ct{'Tests'} that comprises \ct{'CoolBrowser-Tests'} and \ct{'CoolBrowser-AddonsTests'}. 
 
Groups are useful because they let you name sets of items for various purposes. Maybe you want to offer the  user the possibility of installing just the core, or the core with add-ons and development features: you can make this easy be defining appropriate groups.  Let's go back to our example, and look at how we might define a new baseline, \ct{'0.6-baseline'} that defines 6 groups, as shown in \figref{version06}. 

\begin{figure}
\begin{center}
\includegraphics[width=0.9\linewidth]{version06}
\caption{A baseline with six groups: default, Core, Extras, Tests, CompleteWithoutTests and CompleteWithTests.\label{fig:version06}}
\end{center}
\end{figure} 


To define a group we use the method \mbox{\ct{group: groupName with: group elements}.} The {with:} argument can be a package name, a project, another group, or a collection of those things.  Here is the code correspondiong to \figref{version06}.
 
\begin{code}{}
ConfigurationOfCoolBrowser>>baseline06: spec 
     <version: '0.6-baseline'>
!\vspace{-0.7ex}!
     spec for: #common do: [
          spec blessing: #baseline.
          spec repository: 'http://www.example.com/CoolBrowser'.
!\vspace{-0.7ex}!
          spec 
                 package: 'CoolBrowser-Core';
                 package: 'CoolBrowser-Tests' with: [ spec requires: 'CoolBrowser-Core' ];
                 package: 'CoolBrowser-Addons' with: [ spec requires: 'CoolBrowser-Core' ] ;
                 package: 'CoolBrowser-AddonsTests' with: [ 
                      spec requires: #('CoolBrowser-Addons' 'CoolBrowser-Tests' ) ].
          spec 
                 !\textbf{group: 'default' with: \#('CoolBrowser-Core' 'CoolBrowser-Addons')}!;
                 group: 'Core' with: #('CoolBrowser-Core');
                 group: 'Extras' with: #('CoolBrowser-Addon');
                 group: 'Tests' with: #('CoolBrowser-Tests' 'CoolBrowser-AddonsTests');
                 group: 'CompleteWithoutTests' with: #('Core' 'Extras');
                 group: 'CompleteWithTests' with: #('CompleteWithoutTests' 'Tests')
               ].
\end{code}






 
Note that we are defining the groups in the baseline version, since a group is a structural component. Using this baseline, we can now define version \ct{0.6} to be the same as version\ct{0.5}, except for the addition of the new package \ct{CoolBrowser-AddonsTests}.
 
\begin{code}{}
ConfigurationOfCoolBrowser>>version06: spec 
       <!\textbf{version: '0.6' imports: \#('0.6-baseline')}!>
!\vspace{-0.7ex}!
      spec for: #common do: [
            spec blessing: #development.
            spec 
                  package: 'CoolBrowser-Core' with: 'CoolBrowser-Core-MichaelJones.20';
                  package: 'CoolBrowser-Tests' with: 'CoolBrowser-Tests-JohnLewis.8';
                  package: 'CoolBrowser-Addons' with: 'CoolBrowser-Addons-JohnLewis.6' ;
                  package: 'CoolBrowser-AddonsTests' with: 'CoolBrowser-AddonsTests-JohnLewis.1' ].
\end{code}
 

\paragraph{Examples.} Once you have defined a group, you can use its name anywhere that you would use the name of a project or package. The \ct{load:}  method takes as parameter the name of a package, a project, a group, or a collection of those items.  So all of the following statements are possible:

 
\begin{code}{}
(ConfigurationOfCoolBrowser project version: '0.6') load: 'CoolBrowser-Core'. 
       "Load a single package"

(ConfigurationOfCoolBrowser project version: '0.6') load: 'Core'. 
       "Load a single group"

(ConfigurationOfCoolBrowser project version: '0.6') load: 'CompleteWithTests'.  
       "Load a single group"
 
(ConfigurationOfCoolBrowser project version: '0.6') 
       load: #('CoolBrowser-Core' 'Tests').    
       "Loads a package and a group"

(ConfigurationOfCoolBrowser project version: '0.6') 
       load: #('CoolBrowser-Core' 'CoolBrowser-Addons' 'Tests'). 
       "Loads two packages and a group" 

(ConfigurationOfCoolBrowser project version: '0.6') 
       load: #('CoolBrowser-Core' 'CoolBrowser-Tests').
       "Loads two packages"
  
(ConfigurationOfCoolBrowser project version: '0.6') load: #('Core' 'Tests'). 
       "Loads two groups"
\end{code}


\paragraph{The groups \lct{'default'} and \lct{'ALL'}.} The \ct{'default'} group is special.  When a group named \ct{'default'} is defined, the \ct{load} method loads the members of the \ct{'default'} group instead of all of the packages in the project.  So
    
\begin{code}{}
(ConfigurationOfCoolBrowser project version: '0.6') load.
\end{code}

\noindent
loads just \ct{'CoolBrowser-Core'} and \ct{'CoolBrowser-Addons'}.

In the presence of a \ct{'default'} group, how do you load all the packages of a project?  You use the predefined group \ct{'ALL'}, as shown below: 

\begin{code}{}
(ConfigurationOfCoolBrowser project version: '0.6') load: 'ALL'.
\end{code}
 

\section{Dependencies Between Projects}

In the same way that a package can depend on other packages, a project can depend on other projects.  For example, Pier, which is a content management system that uses meta-description, depends on Magritte and Seaside.  A project can depend on the entirety of one or more other projects, on a group of packages from another project, or on just one or two packages from another project.

How we describe project dependencies depends on whether or not the other projects are described using Metacello. 

\subsection{Depending on a project \emph{without} a Metacello description}

Suppose that package A from Project X depends on package B from project Y, and that project Y has not been described using Metacello.  (This might be because there is only one package in project Y). 
In this case we can describe the dependency as follows:
\sd{we should use the same example A and B sucks}
\begin{code}{}
      "In the baseline method"
      spec 
             package: 'PackageA' with: [  spec requires: #('PackageB')];
             package: 'PackageB' with: [  spec 
                   repository: 'http://www.squeaksource.com/ProjectB' ].       
\end{code}

\begin{code}{}
      ``In the version method"
      package: 'PackageB' with: 'PackageB-JuanCarlos.80'.
\end{code}

This works, up to a point.  The shortcoming of this approach is that (because  project B is not described by a Metacello configuration) the dependencies of B are not managed. 
That is, any dependencies of package B will not be loaded. So, our recommendation is that in this case, you take the time to create a configuration for the project B.

\subsection{Depending on a project \emph{with} a Metacello configuration}
Now let us look at the case where the projects on which we depend are described using Metacello.
Let's introduce a new project called \ct{CoolToolSet} that uses the packages from the \ct{CoolBrowser} project.  Its configuration class is called \ct{ConfigurationOfCoolToolSet}.   Suppose that there are two packages in \ct{CoolToolSet} called \ct{CoolToolSet-Core} and \ct{CoolToolSet-Tests}. Of course, these packages depend on packages from \ct{CoolBrowser}. Let's also assume  that the class \ct{ConfigurationOfCoolBrowser} is stored in a Monticello package called \ct{CoolBrowser-Metacello} rather than the recommended \ct{ConfigurationOfCoolBrowser}. This will help us to understand the role of each parameter. 

Version \ct{'0.1'} of \ct{CoolToolSet} is just a normal version that imports a baseline:
\begin{code}{}
ConfigurationOfCoolToolSet>>version01: spec 
       <version: '0.1' imports: #('0.1-baseline')>
       spec for: #common do: [
              spec 
                     package: 'CoolToolSet-Core' with: 'CoolToolSet-Core-AlanJay.1';
                     package: 'CoolToolSet-Tests' with: 'CoolToolSet-Tests-AlanJay.1'.].       
\end{code}       
\noindent
Here is the baseline:
\begin{code}{}
ConfigurationOfCoolToolSet >>baseline01: spec 
       <version: '0.1-baseline'>
       spec for: #common do: [
              spec repository: 'http://www.example.com/CoolToolSet'.
              spec project: 'CoolBrowser ALL' with: [
                            spec 
                                   !\textbf{className:}! 'ConfigurationOfCoolBrowser';
                                   versionString: '1.0';
                                   loads: #('ALL' );
                                   !\textbf{file:}! 'CoolBrowser-Metacello';
                                   !\textbf{repository:}! 'http://www.example.com/CoolBrowser' ].
              spec 
                     package: 'CoolToolSet-Core' with: [ spec requires: 'CoolBrowser ALL' ];
                     package: 'CoolToolSet-Tests' with: [ spec requires: 'CoolToolSet-Core' ]].
\end{code}       


What we did here in \ct{baseline0.1} was to create a \emph{project reference} for the CoolBrowser project (see \figref{version07}). 

\begin{itemize}
\item The message \ct{className:} specifies the name of the class that contains the project metadata; in this case \ct{'ConfigurationOfCoolBrowser'}.

\item The messages \ct{file:} and \ct{repository:} give Metacello the information  that it might need to search for and load class \ct{'ConfigurationOfCoolBrowser'}, if it is not present in the image.  The argument to \ct{file:} is the name of the Monticello package that contains the metadata class, and the argument to \ct{repository:} is the URL of the Monticello repository that contains that package.
If the Monticello repository is protected, then you should use the message: \ct{repository:username:password:} instead.
\ab{I've taken a guess at the meaning of \ct{file:}.  If I'm right, then the name of this message should be changed to \ct{package:}.}

Note that if the package name had followed the normal convention, and had been the same as the class name, then the \ct{file:} message could have been omitted.
\ab{I'm guessing here.  Is this right?  If so, I think that we should describe the normal, simple case here, and then elaborate in a reference section.}

\item The \ct{versionString:} and \ct{loads:} messages specify which version of the project and which packages or groups to load.  The parameter of \ct{loads:} can be the name of a package, or the name of a group, or a collection of these things.
\sd{should I get a version 1.0 of the version/baseline of CoolBrowser. This is not clear and I need to know that.}

\ab{So I could have said \ct{loads: 'ALL';} and that would have meant the same thing?  If so, why didn't I?  And why is this message \ct{loads:} rather than \ct{load:} like the others?}

\end{itemize}

\begin{figure}
\begin{center}
\includegraphics[width=0.9\linewidth]{version07}
\caption{Dependencies between configurations.\label{fig:version07}}
\end{center}
\end{figure} 


We've named the project reference 'CoolBrowser ALL' and in the specification for the 'CoolToolSet-Core' package, we've specified that 'CoolBrowser ALL' is required. The name of the project reference is arbitrary, you can select the name you want, although is recommended to put a name that make sense to that project reference. 
\sd{How can I say that I should load a specific version of another configurations?}

Now we can now load \ct{CoolToolSet} like this:

\begin{code}{}
(ConfigurationOfCoolToolSet project version: '0.1') load.
\end{code}

\noindent
This will cause the entire \ct{CoolBrowser} project to be loaded before \ct{'CoolToolSet-Core'}. 

If we wanted to specify dependencies on CoolBrowser's test package separately from those on the core package, we might define this baseline:

\begin{code}{}
ConfigurationOfCoolToolSet >>baseline02: spec 
       <version: '0.2-baseline'>
       spec for: #common do: [
              spec blessing: #baseline.
              spec repository: 'http://www.example.com/CoolToolSet'.
              spec
                     project: 'CoolBrowser default' with: [
                            spec
                                   className: 'ConfigurationOfCoolBrowser';
                                   versionString: '1.0';
                                   loads: #('default' );
                                   file: 'CoolBrowser-Metacello';
                                   repository: 'http://www.example.com/CoolBrowser' ];
                     project: 'CoolBrowser Tests' with: [
                            spec
                                   className: 'ConfigurationOfCoolBrowser';
                                   versionString: '1.0';
                                   loads: #('Tests' );
                                   file: 'CoolBrowser-Metacello';
                                   repository: 'http://www.example.com/CoolBrowser' ].
              spec 
                     package: 'CoolToolSet-Core' with: [ spec requires: 'CoolBrowser default' ];
                     package: 'CoolToolSet-Tests' with: [ 
                            spec requires: #('CoolToolSet-Core'  'CoolBrowser Tests'  ) ].].                     
\end{code}

This creates \emph{two} project references: the reference named \ct{'CoolBrowser default'} loads the 'default' group and the reference named 'CoolBrowser Tests'  loads the 'Tests' group of the configuration of Cool Browser. We then made \ct{'CoolToolSet-Core'} require \ct{'CoolBrowser default'} and \ct{'CoolToolSet-Tests'} require \mbox{\ct{'CoolToolSet-Core'}} and \ct{'CoolBrowser Tests'}.

Now it is possible to load just the core packages:

\begin{code}{}
(ConfigurationOfCoolToolSet project version: '1.1') load: 'CoolToolSet-Core'.
\end{code}
\noindent
or the core including tests:
\begin{code}{}
  (ConfigurationOfCoolToolSet project version: '1.1') load: 'CoolToolSet-Tests'.
\end{code}

As you can see, in \ct{baseline02:} information is duplicated in the two project references. To remove that duplication, we can use the \ct{project:copyFrom:with:} method.  For example:

\begin{code}{}
ConfigurationOfCoolToolSet >>baseline02: spec 
       <version: '0.2-baseline'>
       spec for: #common do: [
              spec blessing: #baseline.
              spec repository: 'http://www.example.com/CoolToolSet'.
              spec project: 'CoolBrowser default' with: [
                            spec
                                   className: 'ConfigurationOfCoolBrowser';
                                   versionString: '1.0';
                                   loads: #('default');
                                   file: 'CoolBrowser-Metacello';
                                   repository: 'http://www.example.com/CoolBrowser' ];
                     project: 'CoolBrowser Tests' 
                            !\textbf{copyFrom:}! 'CoolBrowser default' 
                            !\textbf{with:}! [ spec loads: #('Tests').].
              spec 
                     package: 'CoolToolSet-Core' with: [ spec requires: 'CoolBrowser default' ];
                     package: 'CoolToolSet-Tests' with: [ 
                            spec requires: #('CoolToolSet-Core' 'CoolBrowser Tests') ].].                                   
\end{code}

In this baseline,  and also in \ct{baseline01}, we did something that is not always useful: we put the version of the referenced projects in the baseline instead of in the version method. If you look at \ct{baseline01} you can see that we used \ct{versionString: '1.0'}.  If the project on which you are depending changes often, and you want to follow the changes,  this will force you to update your baseline frequently, which is undesirable.  So, depending on the context, it may be better to specify the \ct{#versionString:} in the version method instead of in the baseline method: 

\begin{code}{}
ConfigurationOfCoolToolSet>>version02: spec 
       <version: '0.2' imports: #('0.2-baseline' )>
       spec for: #common do: [
              spec blessing: #beta.
              spec 
                     package: 'CoolToolSet-Core' with: 'CoolToolSet-Core-AlanJay.1';
                     package: 'CoolToolSet-Tests' with: 'CoolToolSet-Tests-AlanJay.1';
                     !\textbf{project:}! 'CoolBrowser default' !\textbf{with:}! '1.3';
                     !\textbf{project:}! 'CoolBrowser Tests' !\textbf{with:}! '1.3'].
\end{code}

\ab{Why \ct{with:} and not \ct{versionString:}?  Elsewhere, \ct{with:} has been used for general overrides and takes a block.}

If we don't define a version for the references \ct{'CoolBrowser default'}  and \ct{'CoolBrowser Tests'} in the version method, then the version specified in the baseline is used. If there is no version specified in the baseline method, then Metacello loads the most recent version of the project.

\section{Executing code before and after installation}

Occasionally, you may find that you need to execute some code either before or after a package or project is loaded. For example, if you are installing a System Browser it would be a good idea to register it as default after it is loaded. Or maybe you want to open some workspaces after the installation. 

Metacello provides this feature by means of the messages \ct{preLoadDoIt:} and \ct{postLoadDoIt:}.  The arguments to these messages are selectors of methods defined on the configuration class as shown below. For the moment, these pre- and post-scripts can be defined for a single package or for an entire project. 
%Revisar cuando Dale soporte esto en grupos o a referencias de projectos. 

Continuing with our example:

\begin{code}{}
ConfigurationOfCoolBrowser>>version08: spec 
       <version: '0.8' imports: #('0.7-baseline')>
       
       spec for: #common do: [
              spec 
                     package: 'CoolBrowser-Core' with: [
                            spec 
                                   file: 'CoolBrowser-Core-MichaelJones.20';
                                   !\textbf{preLoadDoIt:}! #preloadForCore;
                                   !\textbf{postLoadDoIt:}! #postloadForCore:package: ];
                     ....
                     package: 'CoolBrowser-AddonsTests' with: 'CoolBrowser-AddonsTests-JohnLewis.1' ].
\end{code}

\begin{code}{}
ConfigurationOfCoolBrowser>>preloadForCore
         Transcript show: 'This is the preload script. Sorry I had no better idea'. 
\end{code}

\begin{code}{}
ConfigurationOfCoolBrowser>>postloadForCore: loader package: packageSpec
       Transcript cr; 
              show: '#postloadForCore executed, Loader: ', loader printString, 
                     ' spec: ', packageSpec printString.
       
       Smalltalk at: #SystemBrowser ifPresent: [:cl | cl default: (Smalltalk classNamed: #CoolBrowser)].
\end{code}

As you can notice there, both methods, \ct{preLoadDoIt:} and \ct{postLoadDoIt:} receive a selector that will be performed before or after the load. You can also note that the method  \ct{postloadForCore:package:} takes two parameters. The pre/post load methods may take 0, 1 or 2 arguments. The {\em loader} \sd{should explain that} is the first optional argument and the loaded packageSpec is the second optional argument. Depending on your needs you can choose which of those arguments do you want.

These pre and post load scripts can be used not only in version methods but also in baselines. If a script depends on a version, then you can put it there. If it is likely not to change among different versions, you can put it in the baseline method exactly in the same way.

As we said before, these pre and post it can be at package level, but also at project level. For example, we can have the following configuration:

\begin{code}{} 
ConfigurationOfCoolBrowser>>version08: spec 
       <version: '0.8' imports: #('0.7-baseline')>
       
       spec for: #common do: [
              spec blessing: #release.
              
              spec !\textbf{preLoadDoIt:}! #preLoadForCoolBrowser.
              spec !\textbf{postLoadDoIt:}! #postLoadForCoolBrowser.
       
              spec 
                     package: 'CoolBrowser-Core' with: [
                            spec 
                                   file: 'CoolBrowser-Core-MichaelJones.20';
                                   preLoadDoIt: #preloadForCore;
                                   postLoadDoIt: #postloadForCore:package: ];
                     package: 'CoolBrowser-Tests' with: 'CoolBrowser-Tests-JohnLewis.8';
                     package: 'CoolBrowser-Addons' with: 'CoolBrowser-Addons-JohnLewis.6' ;
                     package: 'CoolBrowser-AddonsTests' with: 'CoolBrowser-AddonsTests-JohnLewis.1' ].
\end{code}

In this example, we added pre and post load scripts at project level. Again, the selectors can receive 0, 1 or 2 arguments. 

%Mostrar ejemplos con scripts a nivel de projecto o referencia a projectos.

\section {Platform specific package}

Suppose that we want to have different packages loaded depending on the platform the configuration is loaded in. In the context of our example our Cool Browser we can have a package called \ct{CoolBrowser-Platform}. There we can define abstract classes, APIs, etc. And then, we can have the following packages: \ct{CoolBrowser-PlatformPharo}, \ct{CoolBrowser-PlatformGemstone}, etc.

Metacello automatically loads the package of the platform where we are loading the code. But to do that, we need to give Metacello  platform specific information using the method \ct{for:do:} as shown in the following example.

\begin{code}{} 
ConfigurationOfCoolBrowser>>version09: spec 
       <version: '0.9' imports: #('0.9-baseline')>
       
       !\textbf{spec for: \#common do: [}!
              ...
              spec 
                 ...
                     package: 'CoolBrowser-AddonsTests' with: 'CoolBrowser-AddonsTests-JohnLewis.1' ].
       
       !\textbf{spec for: \#gemstone do: [}!
              spec package: 'CoolBrowser-Platform' with: 'CoolBrowser-PlatformGemstone-MichaelJones.4'.].
       !\textbf{spec for: \#pharo do: [}!
              spec package: 'CoolBrowser-Platform' with: 'CoolBrowser-PlatformPharo-JohnLewis.7'.].
       !\textbf{spec for: \#squeak do: [}!
              spec package: 'CoolBrowser-Platform' with: 'CoolBrowser-JohnLewis-dkh.3'.].
\end{code}

You see that the version can handle different platform.


\begin{code}{}
ConfigurationOfCoolBrowser>>baseline09: spec 
       <version: '0.9-baseline'>
       
       spec for: #common do: [
              spec blessing: #baseline.
              spec repository: 'http://www.example.com/CoolBrowser'.
              
              spec 
                     package: 'CoolBrowser-Core';
                     package: 'CoolBrowser-Tests' with: [ spec requires: 'CoolBrowser-Core' ];
                     package: 'CoolBrowser-Addons' with: [ spec requires: 'CoolBrowser-Core' ] ;
                     package: 'CoolBrowser-AddonsTests' with: [ 
                            spec requires: #('CoolBrowser-Addons' 'CoolBrowser-Tests' ) ].
              spec 
                     group: 'default' with: #('CoolBrowser-Core' 'CoolBrowser-Addons' );
                     group: 'Core' with: #('CoolBrowser-Core' 'CoolBrowser-Platform' );
                     group: 'Extras' with: #('CoolBrowser-Addon');
                     group: 'Tests' with: #('CoolBrowser-Tests' 'CoolBrowser-AddonsTests' );
                     group: 'CompleteWithoutTests' with: #('Core', 'Extras' );
                     group: 'CompleteWithTests' with: #('CompleteWithoutTests', 'Tests' )].
                     
       !\textbf{spec for: \#gemstone do: [}!
              spec package: 'CoolBrowser-Platform' with: 'CoolBrowser-PlatformGemstone'.].
       !\textbf{spec for: \#pharo do: [}!
              spec package: 'CoolBrowser-Platform' with: 'CoolBrowser-PlatformPharo'.].
       !\textbf{spec for: \#squeak do: [}!
              spec package: 'CoolBrowser-Platform' with: 'CoolBrowser-PlatformSqueak'.].
\end{code}

Notice that we add the package \ct{CoolBrowser-Platform} in the \ct{Core} group. As you can see, we can manage this package as any other and in a uniform way. Thus, we have a lot of flexibility. At runtime, when you load CoolBrowser, Metacello automatically detects in which dialect the load is happening and loads the specific package for that dialect.         

Finally, note that the method \ct{for:do:} is not only used to specify a platform specific package, but also for anything that has to do with different dialects. You can put whatever you want from the configuration inside that block. So, for example, you can define groups, packages, repositories, etc, that are dependent on a dialect. For example, you can do this:


  \begin{code}{}
 ConfigurationOfCoolBrowser>>baseline010: spec 
       <version: '0.10-baseline'>
       
       spec for: #common do: [
              spec blessing: #baseline.].
       
       spec for: #pharo do: [
              spec repository: 'http://www.pharo.com/CoolBrowser'.
              
              spec 
                     ...
              spec 
                     group: 'default' with: #('CoolBrowser-Core' 'CoolBrowser-Addons' );
                     group: 'Core' with: #('CoolBrowser-Core' 'CoolBrowser-Platform' );
                     group: 'Extras' with: #('CoolBrowser-Addon');
                     group: 'Tests' with: #('CoolBrowser-Tests' 'CoolBrowser-AddonsTests' );
                     group: 'CompleteWithoutTests' with: #('Core', 'Extras' );
                     group: 'CompleteWithTests' with: #('CompleteWithoutTests', 'Tests' )].
                     
       spec for: #gemstone do: [
              spec repository: 'http://www.gemstone.com/CoolBrowser'.
              
              spec 
                     package: 'CoolBrowser-Core';
                     package: 'CoolBrowser-Tests' with: [ spec requires: 'CoolBrowser-Core' ];
              spec 
                     group: 'default' with: #('CoolBrowser-Core' 'CoolBrowser-Addons' );
                     group: 'Core' with: #('CoolBrowser-Core' 'CoolBrowser-Platform' )].                     

\end{code}       
       
In this example, for Pharo we use a different repository than for Gemstone. However, this is not mandatory, since both can have the same repository and differ in other things like versions, post and pre code executions, dependencies, etc. 

In addition, the addons and tests are not available for Gemstone, and thus, those packages and groups are not included. So, as you can see, all what we have been doing inside the \ct{for: #common: do:} can be done inside another \ct{for:do:} for a specific dialect. 


%\section{Grouping projects} 
%
%Usually, a project has more than one package and/or the package has dependencies upon other configurations. If such is the case it is common to create a separate configuration for all those packages or projects. With this, I can reuse dependency and version information among other projects. 
%
%Maybe the sole purpose of this configuration is to group packages or projects and define stable version for them so that they can be used in different projects. 








\section{Symbolic Versions}
In any large evolving application relying on other applications and libraries, it is difficult to know which version of a configuration to use with a specific versions. This is especially true for Pharo applications where some people should maintained applications developed for a given version, while others are working on the latest build.

\ct{ConfigurationOfOmniBrowser} provides a good example of the problem: 
version 1.1.3 is used in the Pharo1.0 one-click image,  version 1.1.3 cannot be loaded into Pharo1.2,  version 1.2.3 is currently the latest \ct{development} version aimed at Pharo1.2, and version 1.2.3 cannot be loaded into Pharo1.0. 

Obviously version 1.1.3 should be used in Pharo1.0 and version 1.2.3 should be used in Pharo1.2. Now up until recently there is no way for a developer to communicate this information to his users using Metacello.

The latest version of Metacello introduces \emph{symbolic versions} whose purpose is to provide a way to describe versions in terms of existing literal versions (like 1.1.3, 1.1.5 and 1.2.3). Symbolic versions are specified using the \ct{symbolicVersion:} pragma:

\begin{code}{}
OmniBrowser>>stable: spec
     <symbolicVersion: #stable>
     spec for: #'pharo1.0.x' version: '1.1.3'.
     spec for: #'pharo1.1.x' version: '1.1.5'.
     spec for: #'pharo1.2.x' version: '1.2.3'.
\end{code}

Symbolic versions can be used anywhere that a literal version can be used. From a load expressions such as \ct{(ConfigurationOfOmniBrowser project version: #stable) load}
to a project reference in a baseline version:

\begin{code}{}
baseline10: spec
  <version: '1.0-baseline'>
  spec for: #squeakCommon do: [
     spec blessing: #baseline.
     spec repository: 'http://seaside.gemstone.com/ss/GLASSClient'.
     spec
        project: 'OmniBrowser' with: [
          spec
             className: 'OmniBrowser';
             !\textbf{versionString: \#stable;}!
             repository: 'http://www.squeaksource.com/MetacelloRepository' ].
     spec
         package: 'OB-SUnitGUI' with: [
            spec requires: #( 'OmniBrowser') ];
         package: 'GemTools-Client' with: [
            spec requires: #( 'OB-SUnitGUI'. ) ];
         package: 'GemTools-Platform' with: [
            spec requires: #( 'GemTools-Client'. ) ]].
\end{code}
Note that the \ct{#stable} here override the bleeding edge loading behavior that you would get if you would be (fool enough) to load a baseline (remeber loading a baseline loads bleeding edge versions). Here we make sure that the stable version of OmniBrowser for your platform will be loaded (and not the latest one).
    
%%version number
%%stable = I do not care except that I want a certified version for the platform.
%%development = I do not care except that I want a certified version for the platform but in dev mode.
%%bleedingEdge = latest (file)

    
    
    
    
    
\subsection{Project Blessing and Loading}

In software development it is very common that packages or projects pass through several stages or steps during the software development process or life cycle such as for example, development, alpha, beta,  release, release candidate, etc. Sometimes we want to refer also to the state of a project.
 %or sometimes we just want to use any other tag that may be useful. The blessing attribute can be used for all of these cases. --- would be better tohave separated tag: attributes.

\sd{Not sure if the following is up to date}
Blessings are taken into account by the load logic. The result of the following expression:
\begin{code}{}
ConfigurationOfCoolBrowser project latestVersion.
\end{code}
is not always the last version.  This is because \ct{latestVersion} answers the latest version whose blessing is {\em not} \ct{#development}, \ct{#broken}, or \ct{#blessing}. To find the latest \ct{#development} version for example, you should execute this expression:

\begin{code}{}
ConfigurationOfCoolBrowser project latestVersion: #development.
\end{code}

Nevertheless, you can get the very last version independently of blessing using the \ct{lastVersion} method as illustrated below

\begin{code}{}
ConfigurationOfCoolBrowser project lastVersion.
\end{code}

In general, the \ct{#development} blessing should be used for any version that is unstable. Once a version has stabilized, a different blessing should be applied.

The following expression will load the latest version of all of the packages for the latest \ct{#baseline} version:
 \begin{code}{}
(ConfigurationOfCoolBrowser project latestVersion: #baseline) load.
\end{code}

Since the latest \ct{#baseline} version should reflect the most up-to-date project structure, executing the previous expression loads the absolute bleeding edge version of the project. 



\subsection{Standard Symbolic Versions}

A couple of standard symbolic versions have already been defined:

\begin{description}
\item [bleedingEdge.]  A symbolic version that specifies the latest mcz files and project versions. By default the \ct{bleedingEdge} symbolic version is defined as the latest baseline version available. The default specification for \ct{bleedingEdge} is defined for all projects. The \ct{bleedingEdge} version is primarily for developers who know what they are doing. There are no guarantees that the \ct{bleedingEdge} version will even load, let alone function correctly.

\item [development.] A symbolic version that specifies the literal version to use under development (i.e., whose blessing is \ct{development}). Typically a \ct{development} version is used by developers for managing pre-release activities as the project transitions from \ct{bleedingEdge} to \ct{stable}. There are a number of \ct{MetacelloToolBox} methods that take advantage of the \ct{development} symbolic version.

\item [stable.] A symbolic version specifies the stable literal version for a particular platform. The stable version is the version that should be used for loading.
With the exception of the \ct{bleedingEdge} version (which has a pre-defined default defined), you will need to edit your configuration to add the \ct{stable} or \ct{development} version information.
\end{description}

\sd{I have the impression that this is not clear. it would be good to have an example from something stable and may from moose?}
\sd{How do I say that default is load stable? should I say it? same question for the other ones like bleedingEdge}


When specifying a symbolic version with a \ct{symbolicVersion:} pragma it is legal to use another symbolic version like the following definition for the symbolic version \ct{stable}:

\begin{code}{}
stable: spec
       <symbolicVersion: #stable>

       spec for: #gemstone version: '1.5'.
       spec for: #'squeak' version: '1.4'.
       spec for: #'pharo1.0.x' version: '1.5'.
       spec for: #'pharo1.1.x' version: '1.5'.
       spec for: #'pharo1.2.x' version: #development.
\end{code}

Or to use the special symbolic version \ct{notDefined}: as in the following definition of the symbolic version \ct{development}:

\begin{code}{}
development: spec
       <symbolicVersion: #development>

       spec for: #common version: #notDefined.
       spec for: #'pharo1.1.x' version: '1.6'.
       spec for: #'pharo1.2.x' version: '1.6'.
\end{code}

Here this indicates that there are no version for the \ct{common} tag. 
Using a symbolic version that resolves to \ct{notDefined} will result in a \ct{MetacelloSymbolicVersionNotDefinedError} being signaled.

The following is the definition for the \ct{bleedingEdge} symbolic version: \sd{not sure that it is ok to show here}

\begin{code}{}
bleedingEdge
       <defaultSymbolicVersion: #bleedingEdge>

       | bleedingEdgeVersion |
       bleedingEdgeVersion := (self project map values select: [ :version |
version blessing == #baseline ])
              detectMax: [ :version | version ].
       bleedingEdgeVersion ifNil: [ bleedingEdgeVersion := self project
latestVersion ].
       bleedingEdgeVersion
              ifNil: [ self versionDoesNotExistError: #bleedingEdge ].
       ^ bleedingEdgeVersion versionString
\end{code}


\subsubsection{Hints.}
Some patterns emerge when working with Metacello. Here is a good one: 
Create a baseline version and use the \ct{#stable} version for all of the projects in the baseline. In the literal version, use the explicit version, so that you get an explicit repeatable specification for a set of projects that were known to work together.

Here is an example, the pharo 1.2.2-baseline would include specs that look like this:

\begin{code}{}
 spec
    project: 'OB Dev' with: [
      spec
         className: 'ConfigurationOfOmniBrowser';
         versionString: #stable;
         ...];
    project: 'ScriptManager' with: [
      spec
         className: 'ConfigurationOfScriptManager';
         versionString: #stable;
         ...];
    project: 'Shout' with: [
      spec
         className: 'ConfigurationOfShout';
         versionString: #stable;
         ...];
    ....].
    
 \end{code}

Loading Pharo 1.2.2-baseline would cause the \ct{#stable} version for each of those projects to be loaded ... 
but remember over time the \ct{#stable} version will change and incompatibilities between packages can creep in. 
By using \ct{#stable} versions you will be in better shape than using \ct{#bleedingEdge} because the \ct{#stable} version is known to work.

Pharo 1.2.2 (literal version) will have corresponding specs that look like this:

\begin{code}{}
 spec
    project: 'OB Dev' with: '1.2.4';
    project: 'ScriptManager' with: '1.2';
    project: 'Shout' with: '1.2.2';
    ....].
\end{code}

So that you have driven a stake into the ground stating that these versions are known to work together (have passed tests as a unit). 5 years in the future, you will be able to load Pharo 1.2.2 and get exactly the same packages every time, whereas the \ct{#stable} versions may have drifted over time.

If you are just bringing up a PharoCore1.2 image and would like to load the Pharo dev code, you should load the \ct{#stable} version of Pharo (which may be 1.2.2 today and 1.2.3 tomorrow).
If you want to duplicate the environment that someone is working in, you will ask them for the version of Pharo and load that explicit version to reproduce the bug or whatever. 


\section{Script and Tool Support}
Metacello comes with an API to make the writing of tools for Metacello easier. Two classes exist: \ct{MetacelloBaseConfiguration} and \ct{MetacelloToolBox}. 

\subsection{Development Support}

The \ct{MetacelloBaseConfiguration} class is aimed at eventually becoming the common superclass for all Metacello configurations. For now, though, the class serves as the location for defining the common default symbolic versions (\ct{bleedingEdge} at the present time) and as the place to find development support methods such as the following ones:

\begin{description}
\item \ct{compareVersions}: Compare the \ct{#stable} version to \ct{#development} version.
\item \ct{createNewBaselineVersion}: Create a new baseline version based upon the \ct{#stable} version as a model.
\item \ct{createNewDevelopmentVersion}: Create a new \ct{#development} version using the \ct{#stable} version as model.
\item \ct{releaseDevelopmentVersion}: Release \ct{#development} version: set version blessing to \ct{#release}, update the \ct{#development} and \ct{#stable} symbolic version methods and save the configuration.

\item \ct{saveConfiguration}: Save the mcz file that contains the configuration to it's repository.

\item \ct{saveModifiedPackagesAndConfiguration}: Save modified mcz files, update the \ct{#development} version and then save the configuration.

\item \ct{updateToLatestPackageVersions}: Update the \ct{#development} version to match currently loaded mcz files.

\item \ct{validate} Check the configuration for Errors, Critical Warnings, and Warnings.
\end{description}

\subsection{Metacello Toolbox API}

The \ct{MetacelloToolBox} class is aimed at providing a common API for development scripts and Metacello tools. The development support methods were implemented using the Metacello Toolbox API and the OB-Metacello tools have been reimplemented to use the Metacello Toolbox API.

For an overview of the Metacello Toolbox API, you can look in the HelpBrowser at the 'Metacello>>API Documentation' section. The instance-side methods for MetacelloToolBox support the  programmatic editing of Metacello configurations from the creation of a new configuration classes to the creation and changing of literal and symbolic version methods.

The instance-side methods are intended for the use of Tools developers and are covered in the ProfStef tutorial: 'Inside Metacello Toolbox API'. The class-side methods for MetacelloToolBox support a number of configuration management tasks. The target the initial release of the Metacello Toolbox API is to support the basic Metacello development cycle. In addition to the following section the Metacello development cycle is covered in the ProfStef tutorial: 'Metacello Development Cycle'.


\section{Development Cycle Walk Through}

In this section we'll take a walk through a typical development cycle and provide examples of how the Metacello Toolbox API can be used to support your development process:

\subsection{Example Setup}

When you are developing your project and are building your configuration for the first time, you already have the packages that make up your project loaded and correctly running on your image. In this example, it is necessary to load a set of packages to simulate a image that will be used to build the first configuration of the project. We'll cheat here an use an existing configuration (ConfigurationOfGemTools) to download and install in our image all the packages and dependencies needed (just as we would have to do by hand if we were the maintainers of the project). So, don't pay much attention to this step and only focus on the fact that after evaluating it, you'll have loaded in your image all the packages needed to build the example configuration:

\begin{code}{}
Gofer new
  squeaksource: 'MetacelloRepository';
  package: 'ConfigurationOfGemTools';
  load.
((Smalltalk at: #ConfigurationOfGemTools) project version: '1.0-beta.8.3')
  load: 'ALL'.
\end{code}

GemTools is expected to work in Squeak (Squeak3.10 and Squeak4.1) and Pharo (Pharo1.0 and Pharo1.1). GemTools itself is made up of 5 mcz files from the \url{http://seaside.gemstone.com/ss/GLASSClient} repository and  depends upon 4 other projects: FFI, OmniBrowser, Shout and HelpSystem. 
\begin{itemize}
\item OB-SUnitGUI: requires 'OmniBrowser'. 
\item GemTools-Client: requires 'OmniBrowser', 'FFI', 'Shout', and 'OB-SUnitGUI'. 
\item GemTools-Platform: requires 'GemTools-Client'. 
\item GemTools-Help: requires 'HelpSystem' and 'GemTools-Client'. 
\end{itemize}


\subsection{Project Startup}

\subsubsection{Create Configuration and Initial Baseline}
Here we use the toolbox API to create the initial baseline version by specifying the name, repository, projects, packages, dependencyMap and group composition:

\begin{code}{}
  MetacelloToolBox
     createBaseline: '1.0-baseline'
     for: 'GemToolsExample'
     repository: 'http://seaside.gemstone.com/ss/GLASSClient'
     requiredProjects: #('FFI' 'OmniBrowser' 'Shout' 'HelpSystem')
     packages: #('OB-SUnitGUI' 'GemTools-Client' 'GemTools-Platform' 'GemTools-Help' )
     dependencies:
        {('OB-SUnitGUI' -> #('OmniBrowser')).
        ('GemTools-Client' -> #('OmniBrowser' 'FFI' 'Shout' 'OB-SUnitGUI')).
        ('GemTools-Platform' -> #('GemTools-Client')).
        ('GemTools-Help' -> #( 'HelpSystem' 'GemTools-Client'))}
     groups:
        {('default' -> #('OB-SUnitGUI' 'GemTools-Client' 'GemTools-Platform' 'GemTools-Help'))}.
\end{code}                
                
The \ct{createBaseline:...} message copies the class \ct{MetacelloConfigTemplate} to \ct{ConfigurationOfGemToolsExample} and creates a \ct{#baseline10:} method that looks like the following:

\begin{code}{}
ConfigurationOfGemToolsExample>>baseline10: spec
  <version: '1.0-baseline'>
  spec for: #common do: [
     spec blessing: #'baseline'.
     spec repository: 'http://seaside.gemstone.com/ss/GLASSClient'.
     spec
        project: 'FFI' with: [
          spec
             className: 'ConfigurationOfFFI';
             versionString: #bleedingEdge;
             repository: 'http://www.squeaksource.com/MetacelloRepository' ];
        project: 'OmniBrowser' with: [
          spec
             className: 'ConfigurationOfOmniBrowser';
             versionString: #stable;
             repository: 'http://www.squeaksource.com/MetacelloRepository' ];
        project: 'Shout' with: [
          spec
             className: 'ConfigurationOfShout';
             versionString: #stable;
             repository: 'http://www.squeaksource.com/MetacelloRepository' ];
        project: 'HelpSystem' with: [
          spec
             className: 'ConfigurationOfHelpSystem';
             versionString: #stable;
             repository: 'http://www.squeaksource.com/MetacelloRepository' ].
     spec
        package: 'OB-SUnitGUI' with: [
          spec requires: #('OmniBrowser'). ];
        package: 'GemTools-Client' with: [
          spec requires: #('OmniBrowser' 'FFI' 'Shout' 'OB-SUnitGUI'). ];
        package: 'GemTools-Platform' with: [
          spec requires: #('GemTools-Client'). ];
        package: 'GemTools-Help' with: [
          spec requires: #('HelpSystem' 'GemTools-Client'). ].
     spec group: 'default' with: #('OB-SUnitGUI' 'GemTools-Client'
             'GemTools-Platform' 'GemTools-Help'). ].
\end{code}             



Note that for the 'FFI' project the versionString is \ct{#bleedingEdge}, while the versionString for the other projects is \ct{#stable}. At the time of this writing the FFI project did not have a \ct{#stable} symbolic version defined, so the default versionString is set to \ct{#bleedingEdge}. If a \ct{#stable} symbolic version is defined for the project, the the default versionString is \ct{#stable}. There are no special version dependencies for the GemTools project so the defaults will work just fine.



\subsection{Create Initial Literal Version}

Now we use the toolbox API to create the initial literal version of the project (by literal we mean with numbers identifying the package versions). The toolbox method \ct{createDevelopment:...} bases the definition of the literal version on the baseline version that we created above and uses the currently loaded state of the image to define the project versions and mcz file versions:

\begin{code}{}
  MetacelloToolBox
     createDevelopment: '1.0'
     for: 'GemToolsExample'
     importFromBaseline: '1.0-baseline'
     description: 'initial development version'.
\end{code}

The \ct{createDevelopment:...} method creates a \ct{#version10:} method in your configuration that looks like this:

\begin{code}{}
ConfigurationOfGemToolsExample>>version10: spec
  <version: '1.0' imports: #('1.0-baseline' )>
  spec for: #common do: [
     spec blessing: #development.
     spec description: 'initial development version'.
     spec author: 'dkh'.
     spec timestamp: '1/12/2011 12:29'.
     spec 
        project: 'FFI' with: '1.2';
        project: 'OmniBrowser' with: #stable;
        project: 'Shout' with: #stable;
        project: 'HelpSystem' with: #stable.
     spec
        package: 'OB-SUnitGUI' with: 'OB-SUnitGUI-dkh.52';
        package: 'GemTools-Client' with: 'GemTools-Client-NorbertHartl.544';
        package: 'GemTools-Platform' with: 'GemTools-Platform.pharo10beta-dkh.5';
        package: 'GemTools-Help' with: 'GemTools-Help-DaleHenrichs.24'. ].
\end{code}

Note how the \ct{#stable} symbolic version specifications were carried through into the literal version. If the version isn't \ct{#stable}, then the currentVersion of the project is filled in, just as the current version of each mcz file is set for the packages. Note also that the blessing of the version '1.0' is set to \ct{#development}. By setting the blessing of a newly created version to \ct{#development}, you indicate that the version is under development and is subject to change without notice. The \ct{createDevelopment:...} method also creates a \ct{#development:} method and specifies that version '1.0' is a \ct{#development symbolic version}:

\begin{code}{}
ConfigurationOfGemToolsExample>>development: spec
  <symbolicVersion: #development>
  spec for: #common version: '1.0'.
\end{code}


\subsection{Validation}

Whenever you finish editing a configuration you should validate it to check for mistakes that may cause problems later on. The Metacello ToolBox provides the validation via the message \ct{validateConfiguration:}. The following expression show you possible errors: \ct{(MetacelloToolBox validateConfiguration: ConfigurationOfGemToolsExample) explore}

If the list comes back empty then you are clean. Otherwise you should address the validation issues that show up. Validation issues are divided into three categories:

\begin{description}
\item[Warning -] issues that point out oddities in the definition of a version that do not affect behavior.
\item[Critical Warning -] issues that identify inconsistencies in the definition of a version that may result in unexpected behavior.
\item[ Error -] issues that identify explicit problems in the definition of a version that will result in errors if an attempt is made to resolve the version.
\end{description}

Here's an example of a Critical Warning validation issue:
\begin{code}{}
Critical Warning: No version specified for the project reference 'OCompletion'
                in version '1.1'
     { noVersionSpecified }
     [ ConfigurationOfOmniBrowser #validateVersionSpec: ]
\end{code}     

The first and second line is the explanation, a human readable error message. The third line is the reasonCode, a symbol that represents the category of the issue. You can check out the meanings of the various reasonCodes online or through the following toolbox message:
\ct{(MetacelloToolBox descriptionForValidationReasonCode: #noVersionSpecified)  inspect.}

The fourth line lists the \ct{configurationClass}, \ie the configuration that spawned the issue (there is a different toolbox method for running a recursive configuration validation) and the \ct{callSite}, which is the name of the validation method that generated the error (this is used mainly for debugging).



\subsection{Save Initial Configuration}

The first time you save your configuration, you have to decide where to keep your configuration. It makes sense to keep the configuration in your development repository. The first time that you save your configuration you need to use the MonticelloBrowser or an expression like the following:

\begin{code}{}
  Gofer new
     url: 'http://www.example.com/GemToolsRepository';
     package: 'ConfigurationOfGemToolsExample';
     commit: 'Initial version of configuration'.
\end{code}     


\subsection{Development Cycle}
Now let us look at a typical iteration: testing, releasing, and saving the configuration.
 
\subsubsection{Platform Testing}
To finish the validation of your configuration, you need to do some test loads on your intended platforms. For GemTools we can do a test load into a fresh image (each of the supported PharoCore and Squeak4.1) with the following load expression:

\begin{code}{}
Gofer new
  url: 'http://www.example.com/GemToolsRepository';
  package: 'ConfigurationOfGemToolsExample';
  load.
((Smalltalk at: #ConfigurationOfGemToolsExample)
     project version: #development) load.
\end{code}     
     
Now this is the moment to run the unit tests. Note that for the GemTools unit tests you need to have GemStone installed.

\subsubsection{Release}
Once you are satisfied that the configuration loads correctly on your target platforms, you can release the \ct{#development} into production using the following expression:

\begin{code}{}
  MetacelloToolBox
     releaseDevelopmentVersionIn: ConfigurationOfGemToolsExample
     description: '- release version 1.0'.
\end{code}     

The toolbox method \ct{releaseDevelopmentVersionIn:description:} does the following:
\begin{itemize}
\item set the blessing of the \ct{#development} version to \ct{#release}.
\item sets the \ct{#development} version to \ct{#notDefined}.
\item sets the \ct{#stable} version to the literal version of the \ct{#development} version (in this case '1.0')
\item saves the configuration mcz file to the correct repository.
\end{itemize}


The \ct{development:} method ends up looking like this:

\begin{code}{}
ConfigurationOfGemToolsExample>>development: spec
  <symbolicVersion: #development>
  spec for: #common version: #'notDefined'.
\end{code}  
  
The \ct{stable:} method ends up looking like this:

\begin{code}{}
ConfigurationOfGemToolsExample>>stable: spec
  <symbolicVersion: #stable>
  spec for: #common version: '1.0'.
\end{code}  
  
Finally you can copy the configuration to the MetacelloRepository using the following expression:

\begin{code}{}
  MetacelloToolBox
     copyConfiguration: ConfigurationOfGemToolsExample
     to: 'http://www.squeaksource.com/MetacelloRepository'.
\end{code}


\subsection{Open New Version for Development}

Now we are ready to start new development. The method \ct{createNewDevelopmentVersionIn:...}
performs the necessary modification to be in a state that reflects it. 


\begin{code}{}
MetacelloToolBox
  createNewDevelopmentVersionIn: ConfigurationOfGemToolsExample
  description: '- open 1.1 for development'.
\end{code}

\subsubsection{Configuration Checkpoints}

During the course of development it makes sense to save checkpoints of your development to your repository. To setup this example you should load a newer version of GemTools and get some new mcz files loaded to simulate development:

\begin{code}{}
(ConfigurationOfGemTools project version: '1.0-beta.8.4')
  load: 'ALL'.
\end{code}  

Now that you've simulated some development you can update the \ct{#development} version of your project so that it references the new mcz files you've loaded.

\begin{code}{}
MetacelloToolBox
  updateToLatestPackageVersionsIn: ConfigurationOfGemToolsExample
  description: '- fixed Issue 1090'.
 \end{code} 
 
Then save the configuration to your repository:

\begin{code}{}
MetacelloToolBox
  saveConfigurationPackageFor: 'GemToolsExample'
  description: '- fixed Issue 1090'.
 \end{code}
    
Or do both steps with one toolbox method:

\begin{code}{}
MetacelloToolBox
  saveModifiedPackagesAndConfigurationIn: ConfigurationOfGemToolsExample
  description: '- fixed Issue 1090'.
\end{code}
  
\subsection{Update Project Structure}

In the course of development it is sometimes necessary to add a new package or reference and addition project. In this case let's add a package to the project called 'GemTools-Overrides' ('GemTools-Overrides' is actually part of the GemTools project already and we just left it out of the previous example). To add a new package a project you need to:

\begin{itemize}
\item (1) create a new baseline version to reflect the new package and dependencies, 
\item (2) update existing \ct{#development} version to reference the new baseline version, and 
\item (3) include the explicit version for the new package.
\end{itemize}

You can do that manually by using a class browser to manually:
copy and edit the old baseline version to reflect the new structure
edit the existing \ct{#development} version method
Or you can use the Metacello Toolbox API (not finished/tested yet):

\begin{code}{}
| toolbox |
toolbox := MetacelloToolBox configurationNamed: 'GemToolsExample'.
toolbox
  createVersionMethod: 'baseline11:' inCategory: 'baselines' forVersion: '1.1-baseline';
  addSectionsFrom: '1.0-baseline'
     forBaseline: true
     updateProjects: false
     updatePackages: false
     versionSpecsDo: [ :attribute :versionSpec |
        attribute == #common
          ifTrue: [ versionSpec packages add: (toolbox createPackageSpec: 'GemTools-Overrides') ].
        true ];
  commitMethod;
  modifyVersionMethodForVersion: '1.1'
     versionSpecsDo: [ :attribute :versionSpec |
        attribute == #common
          ifTrue: [ versionSpec packages add: (toolbox createPackageSpec: 'GemTools-Overrides') ].
        false ];
  commitMethod.
\end{code}


\section{Load types}
Metacello lets you specify the way packages are loaded through its ``load types". For the time of this writing, there are only two possible load types: \emph{atomic} and \emph{linear}. 

Atomic loading is used where packages have been partitioned in such a way that they can't be loaded individually. The definitions from each package are munged together into one giant load by the Monticello package loader. Class side \ct{initialize} methods and pre/post code execution are performed for the whole set of packages, not individually. 

If you use a linear load, then each package is loaded in order. Class side \ct{initialize} methods and pre/post code execution are performed just before or after loading that specific package.

It is important to notice that managing dependences does not imply the order packages will be loaded. That a package \emph{A} depends on package \emph{B} doesn't mean that B will be loaded before \emph{A}. It just guarantees that if you want to load \emph{A}, then \emph{B} will be loaded too. 

A problem with this happens also with methods override. If a package overrides a method from another package, and the order is not preserved, then this can be a problem because we are not sure the order they will load, and thus, we cannot be sure which version of the method will be finally loaded. 

When using atomic loading the package order is lost and we have the mentioned problems. However, if we use the linear mode, then each package is loaded in order. Moreover, the methods override should be preserved too. 

A possible problem with linear mode is the following: suppose project \emph{A} depends has dependencies on other two projects \emph{B} and \emph{C}. \emph{B} depends on the project \emph{D} version 1.1 and \emph{C} depends on project \emph{D} version 1.2 (the same project but another version). First question, which \emph{D} version does \emph{A} have at the end?  By default (you can change this using the method \ct{operator:} in the \ct{project} method), Metacello will finally load version 1.2.

However, and here is the relation with load types, in atomic loading \emph{only} 1.2 is loaded. In linear loading, \emph{both} versions may (depending on the dependency order) be loaded, although 1.2 will be finally loaded. But this means that 1.1 may be loaded first and then 1.2. Sometimes this can be a problem because an older version of a package or project may not even load in the Pharo image we are using. 

For all the mentioned reasons, the default mode is linear. Users should use atomic loading in particular cases and when they are completely sure. 

Finally, if you want to explicitly set a load type, you have to do it in the \ct{project} method. Example:

\begin{code}{}
ConfigurationOfCoolToolSet >>project

       ^ project ifNil: [ | constructor |
              "Bootstrap Metacello if it is not already loaded"
              self class ensureMetacello.
              "Construct Metacello project"
              constructor := (Smalltalk at: #MetacelloVersionConstructor) on: self.
              project := constructor project.
              project loadType: #linear. '"or #atomic'"
              project ]

\end{code}


\section{Conditional loading}
When loading a project, usually the user wants to decide whether to load or not certain packages depending on a specific condition, for example, the existence of certain other packages in the image. Suppose you want to load Seaside (or any other web framework) in your image. Seaside has a tool that depends on OmniBrowser and it is used for managing instances of web servers. What can be done with this little tool can also be done by code. If you want to load such tool you need OmniBrowser. However, other users may not need such package. An alternative could be to provide different groups, one that includes such package and one that does not. The problem is that the final user should be aware of this and load different groups in different situations.  With conditional loading you can, for example, load that Seaside tool only if OmniBrowser is present in the image. This will be done automatically by Metacello and there is no need to explicitly load a particular group. 

Suppose that our CoolToolSet starts to provide much more features. We first split the core in two packages: 'CoolToolSet-Core' and 'CoolToolSet-CB'. CoolBrowser can be present in one image but not in another one. We want to load the package 'CoolToolSet-CB' by default only and if CoolBrowser is present. 

The mentioned conditionals are achieved in Metacello by using the \emph{project attributes} we saw in the previous section. They are defined in the \ct{project} method. 
\sd{to me it looks really bad and I'm sure that we want to document that}
Example:


\begin{code}{}
ConfigurationOfCoolBrowser >>project
       |  | 
       ^ project ifNil: [ | constructor |
              "Bootstrap Metacello if it is not already loaded"
              self class ensureMetacello.
              "Construct Metacello project"
              constructor := (Smalltalk at: #MetacelloVersionConstructor) on: self.
              project := constructor project.
              projectAttributes :=  ((Smalltalk at: #CBNode ifAbsent: []) == nil
                     ifTrue: [ #( #'CBNotPresent' ) ]
                     ifFalse: [ #( #'CBPresent' ) ]).
              project projectAttributes:  projectAttributes.
              project loadType: #linear.
              project ]

\end{code}

As you can see in the code, we check if CBNode class (a class from CoolBrowser) is present and depending on that we set an specific project attribute.
This is flexible enough to let you define your own conditions and set the amount of project attributes you wish (you can define an array of attributes).  
Now the questions is how to use these project attributes. In the following baseline we see an example:

\begin{code}{}
ConfigurationOfCoolToolSet >>baseline02: spec 
       <version: '0.2-baseline'>
       
       spec for: #common do: [
              spec blessing: #baseline.
              spec repository: 'http://www.example.com/CoolToolSet'.
              spec project: 'CoolBrowser default' with: [
                            spec
                                   className: 'ConfigurationOfCoolBrowser';
                                   versionString: '1.0';
                                   loads: #('default' );
                                   file: 'CoolBrowser-Metacello';
                                   repository: 'http://www.example.com/CoolBrowser' ];
                     project: 'CoolBrowser Tests' 
                            copyFrom: 'CoolBrowser default' 
                            with: [ spec loads: #('Tests').].
              spec 
                     package: 'CoolToolSet-Core';
                     package: 'CoolToolSet-Tests' with: [ 
                            spec requires: #('CoolToolSet-Core') ];
                     package: 'CoolToolSet-CB';                     
              spec for: #CBPresent do: [
                     spec
                            group: 'default' with: #('CoolToolSet-CB' )
                            yourself ].
              spec for: #CBNotPresent do: [
                     spec 
                            package: 'CoolToolSet-CB' with: [ spec requires: 'CoolBrowser default' ];
                            yourself ].
                     ].
              
\end{code}

You can notice that the way to use project attributes is through the existing method \ct{for:do:}. Inside that method you can do whatever you want: define groups, dependencies, etc. In our case, if CoolBrowser is present, then we just add 'CoolToolSet-CB' to the default group. If it is not present, then 'CoolBrowser default' is added to dependency to 'CoolToolSet-CB'. In this case, we do not add it to the default group because we do not want that. If desired, the user should explicitly load that package also. 

Again, notice that inside the \ct{for:do:} you are free to do whatever you want.

\section{Project version attributes}
 
% First, let us tell you something. Metacello not only includes all what we have been learning and what we will be still learning along this chapter, but also a complete set of tools with UI (user interface). These tools are based on OmniBrowser (OB), and thus, they are called OB-Metacello. This tool lets you save packages, spawn new versions, update package methods, load latest packages, save projects, update projects, among others. Unfortunately, this topic is not covered in this chapter. That's all you need to know for the moment.  
 
A configuration can have several optional attributes such as    
an author, a description, a blessing and a timestamp.  Let's see an example with a new version 0.7 of our project.
 
\begin{code}{}
ConfigurationOfCoolBrowser>>version07: spec 
       <version: '0.7' imports: #('0.7-baseline')>
       
       spec for: #common do: [
              spec blessing: #release.
              !\textbf{spec description: 'In this release .....'.}!
              !\textbf{spec author: 'JohnLewis'.}!
              !\textbf{spec timestamp: '10/12/2009 09:26'.}!
              spec 
                     package: 'CoolBrowser-Core' with: 'CoolBrowser-Core-MichaelJones.20';
                     package: 'CoolBrowser-Tests' with: 'CoolBrowser-Tests-JohnLewis.8';
                     package: 'CoolBrowser-Addons' with: 'CoolBrowser-Addons-JohnLewis.6' ;
                     package: 'CoolBrowser-AddonsTests' with: 'CoolBrowser-AddonsTests-JohnLewis.1' ].
\end{code}
 
We will describe each attribute in detail:
 
\begin{description}

\item[ Description:] a textual description of the version. This may include a list of bug fixes or new features, changelog, etc.
\item[  Author:] the name of the author who created the version. When using the OB-Metacello tools the author field is automatically updated to reflect the current author as defined in the image.
\item[  Timestamp:] the date and time when the version was completed. When using the OB-Metacello tools the timestamp field is automatically updated to reflect the current date and time. Note that the timestamp must be a String.

\end{description}

To end this section, we show you can query this information. This illustrates that most of the information that you define in a Metacello version can then be queried. For example, you can evaluate the following expressions:

\begin{code}{}
(ConfigurationOfCoolBrowser project version: '0.7') blessing.
(ConfigurationOfCoolBrowser project version: '0.7') description.
(ConfigurationOfCoolBrowser project version: '0.7') author.
(ConfigurationOfCoolBrowser project version: '0.7') timestamp.
\end{code}


\section{Conclusion}
Metacello is an important part of Pharo. It will allow your project to scale. It allow you to control when you want to migrate to new version and for which packages. It is an important architectural backbone.


\newpage

\section{Metacello Memento}

\begin{footnotesize}
\begin{code}{}
ConfigurationOfCoolToolSet>>baseline02: spec 						!\emph{"could be called differently just a convention"}!
       <version: '0.2-baseline'> 						                        !\emph{"could be called differently just a convention"}!
       
       spec for: !\textbf{\#common}! do: [                                    !\emph{"\#common/\#pharo/\#gemstone/\#pharo'1.4'"}!     
              spec blessing: #baseline.				                       !\emph{"Important: identifies a baseline"}!  
              spec repository: 'http://www.example.com/CoolToolSet'.
              
              !\emph{"When we depend on other projects"}!
              spec !\textbf{project:}! 'CoolBrowser default' !\textbf{with:}! [
                            spec
                                   className: 'ConfigurationOfCoolBrowser';
                                   !\textbf{versionString:}! #bleedingEdge;			   !\emph{Required field could be \#stable/\#edge/specific version}!
                                   loads: #('default');				!\emph{which group to load}!
                                   file: 'CoolBrowser-Metacello'; !\emph{optional when same as class name}!
                                   repository: 'http://www.example.com/CoolBrowser' ];
                     !\textbf{project:}! 'CoolBrowser Tests' 
                            !\textbf{copyFrom:}! 'CoolBrowser default' 
                            !\textbf{with:}! [ spec loads: #('Tests').].
             
             !\emph{"Our internal package dependencies"}!
              spec 
                     !\textbf{package:}! 'CoolToolSet-Core';
                     !\textbf{package:}! 'CoolToolSet-Tests' !\textbf{with:}! [ spec requires: #('CoolToolSet-Core') ];
                     package: 'CoolToolSet-CB';
          ].  
\end{code}\end{footnotesize} 

\begin{footnotesize}
\begin{code}{}
ConfigurationOfCoolBrowser>>version07: spec 					!\emph{"could be called differently just a convention"}!
       <version: '0.7' imports: #('0.7-baseline')>				!\emph{"could be called differently just a convention: no baseline so this is version"}!
															!\emph{"do not import baseline from other baselines"}!
    
       spec for: !\textbf{\#common}! do: [                            !\emph{"\#common/\#pharo/\#gemstone/\#pharo'1.4'"}! 
              spec !\textbf{blessing:}! #release.		!\emph{"Required \#development/\#release: release means that it will not change anymore"}!
              spec description: 'In this release .....'.
              spec author: 'JohnLewis'.
              spec timestamp: '10/12/2009 09:26'.
              spec 
                     !\textbf{package:}! 'CoolBrowser-Core' !\textbf{with:}! 'CoolBrowser-Core-MichaelJones.20';
                     package: 'CoolBrowser-Tests' with: 'CoolBrowser-Tests-JohnLewis.8';
                     package: 'CoolBrowser-Addons' with: 'CoolBrowser-Addons-JohnLewis.6' ;
                     package: 'CoolBrowser-AddonsTests' with: 'CoolBrowser-AddonsTests-JohnLewis.1' ].
\end{code}
\end{footnotesize} 


\newpage
\begin{footnotesize}
\begin{code}{}
ConfigurationOfGemToolsExample>>development: spec        !\emph{"note that the selector can be anything"}!
       <symbolicVersion: #development>    				!\emph{"\#stable/\#development/\#bleedingEdge"}!
       spec for: #common version: '1.0'.	                   !\emph{"'1.0' is the version of your development version"}!
       !\emph{"\#common or your platform attributes: \#gemstone, \#pharo, or \#'pharo1.4'"}!
\end{code}
\end{footnotesize} 


\begin{footnotesize}
\begin{code}{}
ConfigurationOfGemToolsExample>>baseline10: spec
  <version: '1.0-baseline'>
  spec for: #common do: [
     spec blessing: #'baseline'.                 !\emph{required see above}!
     spec repository: 'http://seaside.gemstone.com/ss/GLASSClient'.
     spec
        !\textbf{project:}! 'FFI' !\textbf{with:}! [
          spec
             className: 'ConfigurationOfFFI';
             !\textbf{versionString:}! #bleedingEdge;					!\emph{\#stable/\#development/\#bleedingEdge}!
             repository: 'http://www.squeaksource.com/MetacelloRepository' ];
        project: 'OmniBrowser' with: [
          spec
             className: 'ConfigurationOfOmniBrowser';
             versionString: #stable;									!\emph{\#stable/\#development/\#bleedingEdge}!
             repository: 'http://www.squeaksource.com/MetacelloRepository' ];
        project: 'Shout' with: [
          spec
             className: 'ConfigurationOfShout';
             versionString: #stable;
             repository: 'http://www.squeaksource.com/MetacelloRepository' ];
        project: 'HelpSystem' with: [
          spec
             className: 'ConfigurationOfHelpSystem';
             versionString: #stable;
             repository: 'http://www.squeaksource.com/MetacelloRepository'].
     spec
        !\textbf{package:}! 'OB-SUnitGUI' !\textbf{with:}! [spec requires: #('OmniBrowser')];
        package: 'GemTools-Client' with: [ spec requires: #('OmniBrowser' 'FFI' 'Shout' 'OB-SUnitGUI' ).];
        package: 'GemTools-Platform' with: [ spec requires: #('GemTools-Client' ). ];
        package: 'GemTools-Help' with: [
          spec requires: #('HelpSystem' 'GemTools-Client' ). ].
     spec !\textbf{group:}! 'default' !\textbf{with:}! #('OB-SUnitGUI' 'GemTools-Client' 'GemTools-Platform' 'GemTools-Help')].
\end{code}         
\end{footnotesize} 







\begin{footnotesize}
\begin{code}{}
ConfigurationOfGemToolsExample>>version10: spec
     <!\textbf{version:}! '1.0' !\textbf{imports:}! #('1.0-baseline' )>
     spec !\textbf{for:}! #common !\textbf{do:}! [
          spec blessing: #development.
          spec description: 'initial development version'.
          spec author: 'dkh'.
          spec timestamp: '1/12/2011 12:29'.
     spec 
          !\textbf{project:}! 'FFI' !\textbf{with:}! '1.2';
          project: 'OmniBrowser' with: #stable;
          project: 'Shout' with: #stable;
          project: 'HelpSystem' with: #stable.
     spec
          !\textbf{package:}! 'OB-SUnitGUI' !\textbf{with:}! 'OB-SUnitGUI-dkh.52';
          package: 'GemTools-Client' with: 'GemTools-Client-NorbertHartl.544';
          package: 'GemTools-Platform' with: 'GemTools-Platform.pharo10beta-dkh.5';
          package: 'GemTools-Help' with: 'GemTools-Help-DaleHenrichs.24'. ].
\end{code}
\end{footnotesize} 

\paragraph{Proposed development process.}
Using metacello we suggest the following development steps.

\begin{code}{}
Baseline						"first we define a baseline"
Version development			"Then a version tagged as development"
Validate the map				"Once it is validated"
Version release				"We are ready to tag a version as release"	

Version development			"Since development continue we create a new version"
...							"Tagged as development. It will be tagged as release and so one"
Baseline 					"When architecture changes, a new baseline will appear"
Version development			"and the story will continue"
Version release

\end{code}

%=========================================================
\ifx\wholebook\relax\else
    \bibliographystyle{jurabib}
    \nobibliography{scg}
    \end{document}
\fi
%=========================================================



%%% Local Variables: 
%%% coding: utf-8
%%% mode: latex
%%% TeX-master: Lint.tex
%%% TeX-PDF-mode: t
%%% End:
