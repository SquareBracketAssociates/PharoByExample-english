\documentclass[a4paper,10pt,twoside]{book}
\usepackage[
	papersize={6in,9in},
	hmargin={.75in,.75in},
	vmargin={.75in,1in},
	ignoreheadfoot
]{geometry}

\usepackage{allsf}
\input
{common.tex}

%=================================================================
% A4
%\documentclass[a4paper,11pt,twoside]{book}
%\input{common.tex}
%\usepackage{a4wide}
%=================================================================
% Add the path for the figures of each chapter here:
\graphicspath{
	{figures/}
	{BasicClasses/figures/}
	{Collections/figures/}
	{Environment/figures/}
	{FirstApp/figures/}
	{Messages/figures/}
	{Metaclasses/figures/}
	{Model/figures/}
	{Morphic/figures/}
	{Preface/figures/}
	{Profiling/figures/}
	{QuickTour/figures/}
	{SUnit/figures/}
	{Streams/figures/} 
	{Syntax/figures/}
}
%=================================================================
\let\wholebook=\relax
\makeindex
\makeglossary
%=================================================================
%\renewcommand{\nnbb}[2]{#2} % Disable editorial comments


\begin{document}
%\synctex=1

\chapter{Managing projects with Metacello}


Have you ever had a problem when trying to load a nice project where you got an error because a package that you were not even aware of  is missing or not correct? You've probably seen such a problem. The problem probably occurred because the project loaded fine for the  developer but only because he has a different context than yours. The project developer did not use a \emph{package management system} to explicitly manage the dependencies between his packages. In this chapter we will show you how to use Metacello, a package management system and the power that you can get using it. 

\section{Introduction}

Metacello is a package \textit{management} system for Monticello. But, exactly what is a \textit{Package Management System}?
It is a collection of tools to automate the process of installing, upgrading, configuring, and removing a set of software packages. It also groups packages to help eliminate user confusion and manages dependencies \ie which versions of what components should be loaded to make sure that the complete system is coherent. 

A package management system provides a consistent method of installing packages. A package management system is sometimes incorrectly referred to as an installer. This can lead to confusion between them. Just for those who are familiar, package management systems for other technologies include Envy (in VisualAge Smalltalk), Maven in Java, apt-get/aptitude in Debian or Ubuntu, etc.

One of the key points of good package management is that \emph{any package should be correctly loaded without needing to manually install anything other than what is specified in the package configuration}. Each dependency, and the dependencies of the dependencies must also be loaded in the correct order. 

If it was not clear enough, the idea is that when using Metacello, you can take a PharoCore image, for example, and load {\em any} package of {\em any} project without any problems with dependencies. Of course, Metacello does not do magic so it is up to the developer  to define the dependencies properly.

% The software is often downloaded from a number of software repositories. It is also common to have a central repository where all the software is submitted but this is totally orthogonal issue.

\section{One tool for each job}

To manage software, Pharo proposes several tools that are very closely related. In Pharo we have three tools: Monticello (which manages versions of source code), Gofer (which is a scripting API for Monticello) and Metacello (which is a package management system).
% it might make sense to talk about Monticello as a Source Code Management system or SCM here? %


%As a principle, we have to know that we need {\em a tool for each job}. A tool cannot do everything. Each tool satisfies a limited amount of problems and it will probably delegate to another tool to do certain tasks. If you read the first Pharo By Example book you may noticed that this concept is quite similar to Object-Oriented Design: we don't want to have only one object that does everything and we rather to have multiple objects where each object has certain behavior and they collaborate together to do a specific task. 
%So we have 

\begin{description}

\item{\textbf{Monticello: Source code versioning.}}
Source code versioning is the process of assigning either unique version names or unique version numbers to unique software states. At a fine-grained level, revision control incrementally keeps track of different versions of ``pieces of software''. In object-oriented programming, these ``pieces of software'' are methods, classes or packages. A versioning system tool lets you commit a new version, update to a new one, merge, diff, revert, etc. Monticello is the source code versioning system used in Pharo and it manages Monticello packages. With Monticello we can do most of the above operations on packages but there is no way to easily specify dependencies, identify stable versions, or group packages into meaningful units.  Monticello just manages package versions. Metacello manages package dependencies and the notion of projects.

\item {\textbf{Gofer: Monticello's Scripting API.}}
Gofer is a small tool on top of Monticello that loads, updates, merges, diffs, reverts, commits, recompiles and unloads groups of Monticello packages. Contrary to existing tools Gofer makes sure that these operations are performed as cleanly as possible. Gofer is a scripting API to Monticello (See Chapter~\ref{}).


\item{\textbf{Metacello: Package Management System.}} Metacello manages projects (sets of related Monticello packages) and their dependencies as well as project metadata. Metacello managaes also dependencies between packages.
\end{description}




\section{Metacello features}

Metacello is consistent with the important features of Monticello. It is based on the following points:

\begin{description}
\item[\textit{Declarative modeling.}] A Metacello project has named versions consisting of lists of explicit Monticello package versions. Dependencies are explicitly expressed in terms of named versions of required projects. A \emph{required project} is a reference to another Metacello project.

\item[\textit{ Distributed repositories.}] Metacello project metadata is represented as instance methods in a class therefore the Metacello project metadata is stored in a Monticello package. As a result, it is easy for distributed groups of developers to collaborate on ad-hoc projects.

\item[\textit{ Optimistic development.}] With Monticello-based packages, concurrent updates to the project metadata can be easily managed. Parallel versions of the metadata can be merged just like parallel versions of the code base itself. 

\end{description}

Additionally, the following points are important considerations for Metacello:

\begin{itemize}
\item Cross-platform operations. Metacello must run on all platforms that support Monticello: currently Pharo, Squeak and GLASS.
\item Conditional Monticello package loading. For projects that are expected to run on multiple platforms, it is essential that platform-specific Monticello packages can be conditionally loaded. 
\end{itemize}

\section{A Simple Case}

Let's start using Metacello for managing a software project called CoolBrowser. The first step is to create a configuration for the project by simply copying the class MetacelloConfigTemplate and naming it ConfigurationOfCoolBrowser (by convention the class name for a Metacello configuration is composed by prefixing the name of the project with \ct{'ConfigurationOf'}). To do this, right click in the class MetacelloConfigTemplate and select the option ``copy''. 

This is the class definition:
\begin{code}{}
Object subclass: #ConfigurationOfCoolBrowser
	instanceVariableNames: 'project'
	classVariableNames: 'LastVersionLoad'
	poolDictionaries: ''
	category: 'Metacello-MC-Model'
\end{code}

You will notice that the \ct{ConfigurationOfCoolBrowser} has some instance and class side methods. We will explain later how they are used. Notice that this class inherits from \ct{Object}.  Metacello configurations should be written such that they can be loaded without any prerequisites, including Metacello itself. So (at least for the time being) Metacello configurations cannot rely on a common superclass.

Now, imagine that the project ``Cool Browser'' has different versions, for example, 1.0, 1.0.1, 1.4, 1.67, etc. 
With Metacello you create an instance side method for each version of the project. Method names for version methods are unimportant as long as the method is annotated with the <version:> pragma as shown below.

By convention the version method is named 'versionXXX:', where XXX is the version number with illegal characters (like '.') removed.

Suppose for the moment that our project ``Cool Browser'' has two packages: \ct{CoolBrowser-Core} and \ct{CoolBrowser-Tests} we name the method \ct{ConfigurationOfCoolBrowser>>version01: spec} as shown below:

\begin{code}{}
ConfigurationOfCoolBrowser>>version01: spec 
	<version: '0.1'>
	
	spec for: #common do: [
		spec repository: 'http://www.example.com/CoolBrowser'.
		spec 
			package: 'CoolBrowser-Core' with: 'CoolBrowser-Core-MichaelJones.10';
			package: 'CoolBrowser-Tests' with: 'CoolBrowser-Tests-JohnLewis.3' ].
\end{code}


In this example, there are a lot of things we need to explain:

\begin{itemize}
\item Immediately after the method selector you see the pragma definition:  {\em <version: '0.1'>}. The pragma indicates that the version created in this method should be associated with version '0.1' of the CoolBrowser project. That's why we said that the name of the method is not that important. Metacello uses the pragma to identify the version being constructed.

\item Looking a little closer you see that the argument to the method, \ct{spec}, is the only variable in
the method and it is used as the receiver to four different messages:   \ct{for:do:},   \ct{package:with:},  \ct{file:}  and  \ct{repository:}.

\item Each time a block expression is executed a new object is pushed on a stack and the messages within the block are sent to the object on the top of the stack.

\item In addition to \ct{#common}, there are pre-defined attributes for each of the platforms upon which Metacello runs (\ct{#pharo}, \ct{#squeak}, \ct{#gemstone} and \ct{#squeakCommon}). Later in the chapter we will detail this feature. 
\end{itemize}


The  method \ct{version01:} should be read as: Create version '0.1'. The common code for version '0.1' (specified using the message \ct{for:do:}) consists of the packages named 'CoolBrowser-Core' (specified using the message \ct{package:with:}) and 'CoolBrowser-Tests'  whose files are named 'CoolBrowser-Core-MichaelJones.10' and 'CoolBrowser-Tests-JohnLewis.3' and whose repository is \ct{'http://www.example.com/CoolBrowser'} (specified using the message \ct{repository:}).

Sometimes, a Monticello repository can be restricted and requires username and password. In such case the following message can be used:

\begin{code}{}
       spec repository: 'http://www.example.com/private' username: 'foo' password: 'bar' 
\end{code}

We can access the specification created for version 0.1 by executing the following expression: \ct{(ConfigurationOfCoolBrowser project version: '0.1') spec}. 

\begin{figure}
\begin{center}
\includegraphics[width=0.6\linewidth]{version01}
\caption{Simple version.}
\end{center}
\end{figure}

\paragraph{Creating a new version.}
Let us assume that the version 0.2 consists of the files 'CoolBrowser-Core-MichaelJones.15' and 'CoolBrowser-Tests-JohnLewis.8' and a new package 'CoolBrowser-Addons' with version 'CoolBrowser-Addons-JohnLewis.3'. Then, all you have to do is to create the following method named \ct{version:}.

\begin{code}{}
ConfigurationOfCoolBrowser>>version02: spec 
	<version: '0.2'>
	
	spec for: #common do: [
		spec repository: 'http://www.example.com/CoolBrowser'.
		spec 
			package: 'CoolBrowser-Core' with: 'CoolBrowser-Core-MichaelJones.15';
			package: 'CoolBrowser-Tests' with: 'CoolBrowser-Tests-JohnLewis.8' ;
			package: 'CoolBrowser-Addons' with: 'CoolBrowser-Addons-JohnLewis.3']
\end{code}
 
\begin{figure}
\begin{center}
\includegraphics[width=0.6\linewidth]{version02}
\caption{An second simple version.}
\end{center}
\end{figure} 
 

\section{Naming your configuration}

In the previous section, we learned that we have to create a class for our configuration. It is not necessary to name this class with a particular name. Nevertheless there is a convention that we recommend you follow. The convention is to name the class \ct{ConfigurationOfXXX} where XXX is your project. In our example, it is \ct{ConfigurationOfCoolBrowser}.

There is a convention also to create a particular package with the same name as the configuration class and put the class there. In our case you will have the package \ct{ConfigurationOfCoolBrowser} with only one class, \ct{ConfigurationOfCoolBrowser}. 

The package name and the class name match and by starting with ConfigurationOfXXX it is easier to scan through a repository listing the available projects. It is also very convenient to have the configurations grouped together rather than jumping around in the browser. That is why the repository \ct{http://www.squeaksource.com/Pharo10MetacelloRepository}, \ct{http://www.squeaksource.com/Pharo11MetacelloRepository} were created. They contain the configurations of several tools and applications and serve as a central repository. 

Having all configurations in the same place has several advantages:
\begin{itemize}
\item Finding the configuration package is easier in the Monticello browser package list.
\item Do not have any conflict with Monticello package naming (for example, you can have the CoolBrowser package and this might conflict with the CoolBrowserConfiguration).
\item When you have to manage multiple Configurations in the PackageBrowser.
\item Given that the name is slightly counter intuitive, it also has very few chances to collide with other names.
\end{itemize}

As a general practice, we suggest that you save the Configuration package in your working project and when you decide 
it is ready you can copy it into the MetacelloRepository. 



\subsection{Loading a Metacello configuration}
Of course, the point of specifying packages in Metacello is to be able to load a coherent set of package versions. Here are a couple of examples for loading versions of the CoolBrowser project. 

If you print the result of each expression, you will see the list of packages in load order. Metacello records not only which packages are loaded but also the order. 

\begin{code}{}
  (ConfigurationOfCoolBrowser project version: '0.1') load.
  (ConfigurationOfCoolBrowser project version: '0.2') load.
\end{code}
  
Note that in each case, all of the packages associated with the version are loaded \--- this  
is the default behavior. If you want to load a subset of the packages in a project, you should list 
the packages that you are interested in as an argument to the \ct{load:} method as shown below:

\begin{code}{}
  (ConfigurationOfCoolBrowser project version: '0.2') load: { 'CoolBrowser-Core' 'CoolBrowser-Addons' }.
\end{code}


\section{Managing packages internal dependencies}

A project is generally composed of several packages which often have dependencies on other packages.  It is probable that a certain package depends on a specific version to behave correctly. Handling dependencies correctlyis really important and this is what Metacello does for us. 

There are two types of dependencies:
\begin{itemize}
\item Internal packages dependencies: Inside a certain project there are several packages and some of them depend on other packages in the same project. 
\item Dependencies between projects. It is common also that a project depends on another project or just on some packages of it. For example Pier (a meta-described cms) depends on Magritte (a meta-data modeling framework) and Seaside (a framework for web application development).
\end{itemize}

For now we will focus on the first case. In our example, imagine that the package \ct{CoolBrowser-Tests} and \ct{CoolBrowser-Addons} depends on \ct{CoolBrowser-Core}. The new configuration \ct{'0.3'} is defined as follows (See Figure~\ref{fig:version03}):

\begin{code}{}
ConfigurationOfCoolBrowser>>version03: spec 
	<version: '0.3'>
	
	spec for: #common do: [
		spec repository: 'http://www.example.com/CoolBrowser'.
		spec 
			package: 'CoolBrowser-Core' with: 'CoolBrowser-Core-MichaelJones.15';
			package: 'CoolBrowser-Tests' with: [
				spec 
					file: 'CoolBrowser-Tests-JohnLewis.8';
					requires: 'CoolBrowser-Core' ];
			package: 'CoolBrowser-Addons' with: [
				spec 
					file: 'CoolBrowser-Addons-JohnLewis.3';
					requires: 'CoolBrowser-Core' ]].
\end{code}

In \ct{version03:} we've added dependency information using the \ct{requires:} directive.
Both \ct{CoolBrowser-Tests} and  \ct{CoolBrowser-Addons} require \ct{CoolBrowser-Core} to be loaded before they are loaded. Pay attention that since we did not specify the exact version number for the \ct{Cool-Browser} package, we can have some problems (but do not worry, we will address this problem soon!).

\begin{figure}
\begin{center}
\includegraphics[width=0.6\linewidth]{version03}
\caption{A version expressing requirements between packages.\label{fig:version03}}
\end{center}
\end{figure} 


With this version we are mixing structural information (required packages and repository) with the file version info. It is expected that over time the file version info will change from
version to version while the structural information will remain relatively the same. To resolve this, Metacello introduces the concept of {\em Baselines}.


\section{Baselining}
A baseline is a concept related to Software Configuration Management (SCM). From this point of view, a baseline is a well-defined, well-documented reference that serves as the foundation for other activities. Generally, a baseline may be a distributed work product, or conflicting work products that can be used as a logical basis for comparison. 

In Metacello, a baseline represents the skeleton of a project in terms of the structural dependencies between packages or projects. A baseline defines the structure of a project using just package names. When the structure changes, the baseline should be updated. In the absence of structural changes, the changes are limited to package versions.

Now, let's continue with our example. First we modify it to use baselines: we create a method per baseline. \sd{is the blessing: baseline important if so we should say it}

\begin{code}{}
ConfigurationOfCoolBrowser>>baseline04: spec 
	<version: '0.4-baseline'>
	
	spec for: #common do: [
		spec blessing: #baseline.
		spec repository: 'http://www.example.com/CoolBrowser'.
		
		spec 
			package: 'CoolBrowser-Core';
			package: 'CoolBrowser-Tests' with: [ spec requires: 'CoolBrowser-Core' ];
			package: 'CoolBrowser-Addons' with: [ spec requires: 'CoolBrowser-Core' ] ].

\end{code}

Baseline \ct{baseline04:} will be used across several versions as for example the version \ct{'0.4'} defined below (see Figure~\ref{}). In method \ct{baseline04:} the structure of version \ct{'0.4-baseline'} is specified. The baseline specifies a repository, the packages, but without version information, and the required packages (dependencies). We'll cover the \ct{blessing:} method  later.

\begin{figure}
\begin{center}
\includegraphics[width=0.6\linewidth]{version04}
\caption{A version now imports a baseline that expresses dependencies between packages.\label{fig:version04}}
\end{center}
\end{figure} 

To define the version, we use another pragma \ct{<version:imports:>} as follows:

\begin{code}{}
ConfigurationOfCoolBrowser>>version04: spec 
	<version: '0.4' imports: #('0.4-baseline')>
	
	spec for: #common do: [
		spec 
			package: 'CoolBrowser-Core' with: 'CoolBrowser-Core-MichaelJones.15';
			package: 'CoolBrowser-Tests' with: 'CoolBrowser-Tests-JohnLewis.8';
			package: 'CoolBrowser-Addons' with: 'CoolBrowser-Addons-JohnLewis.3' ].
\end{code}


In the method \ct{version04:} versions are specified. Note that the pragma \ct{version:imports:} specifies the list of versions that this version (version '0.4') is based upon. In fact, if you print the spec for '0.4-baseline' and then print the spec for '0.4' you will see that '0.4' is a composition of both versions.

Using baseline the way to load this version is still the same:
\begin{code}{}
(ConfigurationOfCoolBrowser project version: '0.4') load.
\end{code}


\paragraph{Loading baselines.}
Even though version \ct{'0.4-baseline'} does not have explicit package versions, you may load it. When the loader encounters a package name without version information it attempts to load the latest version of the package from the repository. Take into account that exactly the same happens if you define a package in a baseline but you don't specify a version for that package in a version method. 
 
\begin{code}{}
(ConfigurationOfCoolBrowser project version: '0.4-baseline') load.
\end{code}

Sometimes when a number of developers are working on a project it may be useful to load a \\ct{baseline} version so that you get the latest work from all of the project members.


\paragraph{New version.}
Now for example, we can have a new version \ct{'0.5'} that has the same baseline (the same structural information), but different packages versions. 

\begin{code}{} 
ConfigurationOfCoolBrowser>>version05: spec 
	<version: '0.5' imports: #('0.4-baseline')>
	
	spec for: #common do: [
		spec 
			package: 'CoolBrowser-Core' with: 'CoolBrowser-Core-MichaelJones.20';
			package: 'CoolBrowser-Tests' with: 'CoolBrowser-Tests-JohnLewis.8';
			package: 'CoolBrowser-Addons' with: 'CoolBrowser-Addons-JohnLewis.6' ].
\end{code}

Note that version \ct{'0.5'} uses the same baseline as version \ct{'0.4'}: \ct{'0.4-baseline'} (see Figure~\ref{fig:version05}).

\begin{figure}
\begin{center}
\includegraphics[width=0.6\linewidth]{version05}
\caption{A second version imports again the baseline.\label{fig:version05}}
\end{center}
\end{figure} 

After all these explanations you may have noticed that creating a baseline for a big project may require time. This is because you must know all the dependencies of all the packages and other things we will see later (this was a simple baseline). Once the baseline is defined, creating new versions of the project is very easy and takes very little time. 

\section{Groups}
Suppose that now the CoolBrowser project is getting better and someone wrote tests for the addons. We have a new package \ct{'CoolBrowser-AddonsTests'}. This package depends on \ct{'CoolBrowser-Addons'} and \ct{'CoolBrowser-Tests'}. \sd{add a figure}

Now we may want to load projects with or without tests. In addition, it would be convenient to be able to load all of the tests with a simple expression like the following:

\begin{code}{}
(ConfigurationOfCoolBrowser project version: '1.0') load: 'Tests'.
\end{code}

instead of having to explicitly list all of the test projects like this:
 
\begin{code}{} 
(ConfigurationOfCoolBrowser project version: '1.0') 
	load: #('CoolBrowser-Tests' 'CoolBrowser-AddonsTests').
\end{code}
 
To solve this problem, Metacello offers the notion of group. A group is a list of items: packages, projects (as we will see in Section~\ref{}) or even other groups. 
 
Groups are very useful because they let you customize different groups of items of different interests. Maybe you want to offer the  user te possibility to install just the core, or with add-ons and development features. Let's go back to our example. Here we defined a new baseline \ct{'0.6-baseline'} which defines 6 groups (see Figure~\ref{fig:version06}). 

To define a group we use the method \ct{group: groupName with: group elements.} The parameter of \ct{with:} can be a package name, a project, another group, or even an collection of those items. This way you can compose groups by using other groups. 
 
\begin{code}{}
ConfigurationOfCoolBrowser>>baseline06: spec 
	<version: '0.6-baseline'>
	
	spec for: #common do: [
		spec blessing: #baseline.
		spec repository: 'http://www.example.com/CoolBrowser'.
		
		spec 
			package: 'CoolBrowser-Core';
			package: 'CoolBrowser-Tests' with: [ spec requires: 'CoolBrowser-Core' ];
			package: 'CoolBrowser-Addons' with: [ spec requires: 'CoolBrowser-Core' ] ;
			package: 'CoolBrowser-AddonsTests' with: [ 
				spec requires: #('CoolBrowser-Addons' 'CoolBrowser-Tests' ) ].
		spec 
			group: 'default' with: #('CoolBrowser-Core' 'CoolBrowser-Addons' );
			group: 'Core' with: #('CoolBrowser-Core');
			group: 'Extras' with: #('CoolBrowser-Addon');
			group: 'Tests' with: #('CoolBrowser-Tests' 'CoolBrowser-AddonsTests' );
			group: 'CompleteWithoutTests' with: #('Core' 'Extras' );
			group: 'CompleteWithTests' with: #('CompleteWithoutTests' 'Tests' )
		 ].
\end{code}


\begin{figure}
\begin{center}
\includegraphics[width=0.6\linewidth]{version06}
\caption{A baseline with groups: default, Core, Extras, Tests, CompleteWithoutTests and CompleteWithTests.\label{fig:version06}}
\end{center}
\end{figure} 




 
Note that we are defining the groups in the baseline version, since groups are a structural component. The package version is the same as version 0.5 in the previous example but with the new package \ct{CoolBrowser-AddonsTests}.
 
\begin{code}{}
ConfigurationOfCoolBrowser>>version06: spec 
	<version: '0.6' imports: #('0.6-baseline')>
	
	spec for: #common do: [
		spec blessing: #development.
		spec 
			package: 'CoolBrowser-Core' with: 'CoolBrowser-Core-MichaelJones.20';
			package: 'CoolBrowser-Tests' with: 'CoolBrowser-Tests-JohnLewis.8';
			package: 'CoolBrowser-Addons' with: 'CoolBrowser-Addons-JohnLewis.6' ;
			package: 'CoolBrowser-AddonsTests' with: 'CoolBrowser-AddonsTests-JohnLewis.1' ].
\end{code}
 

\paragraph{Examples.} Once you have defined group, the idea is that you can use the name of a group anywhere that you would use the name of project or package. The \ct{load:}  method takes as parameter the name of a package, a project, a group or even an collection of those items.  Any of the following statements are then possible:

 
\begin{code}{}
(ConfigurationOfCoolBrowser project version: '1.0') load: 'CoolBrowser-Core'. 
	''Load a single package''

(ConfigurationOfCoolBrowser project version: '1.0') load: 'Core'. 
	''Load a single group''

(ConfigurationOfCoolBrowser project version: '1.0') load: 'CompleteWithTests'.  
	''Load a single group''
 
(ConfigurationOfCoolBrowser project version: '1.0') load: #('CoolBrowser-Core' 'Tests').   
	''Loads a package and a group''

(ConfigurationOfCoolBrowser project version: '1.0') load: #('CoolBrowser-Core' 'CoolBrowser-Addons' 'Tests'). 
	''Loads two packages and a group'' 

 (ConfigurationOfCoolBrowser project version: '1.0') load: #('CoolBrowser-Core' 'CoolBrowser-Tests').
	''Loads two packages''
  
(ConfigurationOfCoolBrowser project version: '1.0') load: #('Core' 'Tests'). 
	''Loads two groups''
\end{code}


\paragraph{Default group.} The \ct{'default'} group is a special one and when a default group is defined, the \ct{load} method loads the members of the 'default' group instead of all of the packages:
   
\begin{code}{}
(ConfigurationOfCoolBrowser project version: '1.0') load.
\end{code}

In such a case, if you want to load all the packages of a project, you should use the predefined group named \ct{'ALL'} as shown below: 

\begin{code}{}
(ConfigurationOfCoolBrowser project version: '1.0') load: 'ALL'.
\end{code}
 

 
\section{Project version attributes}
 
% First, let us tell you something. Metacello not only includes all what we have been learning and what we will be still learning along this chapter, but also a complete set of tools with UI (user interface). These tools are based on OmniBrowser (OB), and thus, they are called OB-Metacello. This tool lets you save packages, spawn new versions, update package methods, load latest packages, save projects, update projects, among others. Unfortunately, this topic is not covered in this chapter. That's all you need to know for the moment.  
 
A configuration can have several optional attributes such as   
an author, a description, a blessing and a timestamp.  Let's see an example with a new version 0.7 of our project.
 
\begin{code}{}
ConfigurationOfCoolBrowser>>version07: spec 
	<version: '0.7' imports: #('0.7-baseline')>
	
	spec for: #common do: [
		
		spec blessing: #release.
		spec description: 'In this release .....'.
		spec author: 'JohnLewis'.
		spec timestamp: '10/12/2009 09:26'.
	
		spec 
			package: 'CoolBrowser-Core' with: 'CoolBrowser-Core-MichaelJones.20';
			package: 'CoolBrowser-Tests' with: 'CoolBrowser-Tests-JohnLewis.8';
			package: 'CoolBrowser-Addons' with: 'CoolBrowser-Addons-JohnLewis.6' ;
			package: 'CoolBrowser-AddonsTests' with: 'CoolBrowser-AddonsTests-JohnLewis.1' ].
\end{code}
 
We will describe each attribute in detail:
 
\begin{description}
\item[ Blessing:] in software development it is very common that packages or projects pass through several stages or steps during the software development process or life cycle such as for example, development, alpha, beta,  release, release candidate, etc. Sometimes we want to refer also to the state of a project.
 %or sometimes we just want to use any other tag that may be useful. The blessing attribute can be used for all of these cases. --- would be better tohave separated tag: attributes.


Blessings are taken into account by the load logic. The result of the following expression:
\begin{code}{}
ConfigurationOfCoolBrowser project latestVersion.
\end{code}
is not always the last version.  This is because \ct{latestVersion} answers the latest version whose blessing is {\em not} \ct{#development}, \ct{#broken}, or \ct{#blessing}. To find the latest \ct{#development} version for example, you should execute this expression:

\begin{code}{}
ConfigurationOfCoolBrowser project latestVersion: #development.
\end{code}

Nevertheless, you can get the very last version independently of blessing using the \ct{lastVersion} method as illustrated below

\begin{code}{}
ConfigurationOfCoolBrowser project lastVersion.
\end{code}

In general, the \ct{\#development} blessing should be used for any version that is unstable. Once a version has stabilized, a different blessing should be applied.

The following expression will load the latest version of all of the packages for the latest \ct{#baseline} version:
 \begin{code}{}
(ConfigurationOfCoolBrowser project latestVersion: #baseline) load.
\end{code}

Since the latest \ct{#baseline} version should reflect the most up-to-date project structure, executing the previous expression loads the absolute bleeding edge version of the project. 


\item[ Description:] a textual description of the version. This may include a list of bug fixes or new features, changelog, etc.
\item[  Author:] the name of the author who created the version. When using the OB-Metacello tools the author field is automatically updated to reflect the current author as defined in the image.
\item[  Timestamp:] the date and time when the version was completed. When using the OB-Metacello tools the timestamp field is automatically updated to reflect the current date and time. Note that the timestamp must be a String.

\end{description}

To end this section, we show you can query this information. This illustrates that most of the information that you define in a Metacello version can then be queried. For example, you can evaluate the following expressions:

\begin{code}{}
(ConfigurationOfCoolBrowser project version: '0.7') blessing.
(ConfigurationOfCoolBrowser project version: '0.7') description.
(ConfigurationOfCoolBrowser project version: '0.7') author.
(ConfigurationOfCoolBrowser project version: '0.7') timestamp.
\end{code}


\section{Pre and post code execution}

Occasionally, you find that you need to perform some code either after or before a package or project is loaded. For example, if we are installing a System Browser it would be a good idea to register it as default after it is loaded. Or maybe you want to open some workspaces after the installation. 

Metacello offers such feature by means of the two methods \ct{preLoadDoIt:} and \ct{postLoadDoIt:}.  The arguments passed to these methods are selectors of methods defined on the configuration class as shown below. For the moment, these pre and post scripts can be assigned to a single package or a whole project. 
%Revisar cuando Dale soporte esto en grupos o a referencias de projectos. 

Continuing with our example:


\begin{code}{}
ConfigurationOfCoolBrowser>>version08: spec 
	<version: '0.8' imports: #('0.7-baseline')>
	
	spec for: #common do: [
		spec blessing: #release.
		spec description: 'In this release .....'.
		spec author: 'JohnLewis'.
		spec timestamp: '10/12/2009 09:26'.
		spec 
			package: 'CoolBrowser-Core' with: [
				spec 
					file: 'CoolBrowser-Core-MichaelJones.20';
					preLoadDoIt: #preloadForCore;
					postLoadDoIt: #postloadForCore:package: ];
			package: 'CoolBrowser-Tests' with: 'CoolBrowser-Tests-JohnLewis.8';
			package: 'CoolBrowser-Addons' with: 'CoolBrowser-Addons-JohnLewis.6' ;
			package: 'CoolBrowser-AddonsTests' with: 'CoolBrowser-AddonsTests-JohnLewis.1' ].
\end{code}

\begin{code}{}
ConfigurationOfCoolBrowser>>preloadForCore
  	Transcript show: 'This is the preload script. Sorry I had no better idea'. 
\end{code}

\begin{code}{}
ConfigurationOfCoolBrowser>>postloadForCore: loader package: packageSpec
	Transcript cr; 
		show: '#postloadForCore executed, Loader: ', loader printString, 
			' spec: ', packageSpec printString.
	
	Smalltalk at: #SystemBrowser ifPresent: [:cl | cl default: (Smalltalk classNamed: #CoolBrowser)].
\end{code}

As you can notice there, both methods, \ct{preLoadDoIt:} and \ct{postLoadDoIt:} receive a selector that will be performed before or after the load. You can also note that the method  \ct{postloadForCore:package:} takes two parameters. The pre/post load methods may take 0, 1 or 2 arguments. The {\em loader} \sd{should explain that} is the first optional argument and the loaded packageSpec is the second optional argument. Depending on your needs you can choose which of those arguments do you want.

These pre and post load scripts can be used not only in version methods but also in baselines. If a script depends on a version, then you can put it there. If it is likely not to change among different versions, you can put it in the baseline method exactly in the same way.

As we said before, these pre and post it can be at package level, but also at project level. For example, we can have the following configuration:

\begin{code}{} 
ConfigurationOfCoolBrowser>>version08: spec 
	<version: '0.8' imports: #('0.7-baseline')>
	
	spec for: #common do: [
		spec blessing: #release.
		spec description: 'In this release .....'.
		spec author: 'JohnLewis'.
		spec timestamp: '10/12/2009 09:26'.
		spec preLoadDoIt: #preLoadForCoolBrowser.
		spec postLoadDoIt: #postLoadForCoolBrowser.
	
		spec 
			package: 'CoolBrowser-Core' with: [
				spec 
					file: 'CoolBrowser-Core-MichaelJones.20';
					preLoadDoIt: #preloadForCore;
					postLoadDoIt: #postloadForCore:package: ];
			package: 'CoolBrowser-Tests' with: 'CoolBrowser-Tests-JohnLewis.8';
			package: 'CoolBrowser-Addons' with: 'CoolBrowser-Addons-JohnLewis.6' ;
			package: 'CoolBrowser-AddonsTests' with: 'CoolBrowser-AddonsTests-JohnLewis.1' ].
\end{code}

In this example, we added pre and post load scripts at project level. Again, the selectors can receive 0, 1 or 2 arguments. 

%Mostrar ejemplos con scripts a nivel de projecto o referencia a projectos.

\section {Platform specific package}

Suppose that we want to have different packages loaded depending on the platform the configuration is loaded in. In the context of our example our Cool Browser we can have a package called \ct{CoolBrowser-Platform}. There we can define abstract classes, APIs, etc. And then, we can have the following packages: \ct{CoolBrowser-PlatformPharo}, \ct{CoolBrowser-PlatformGemstone}, etc.

Metacello automatically loads the package of the platform where we are loading the code. But in order to do that, we need to give Metacello some information using the method \ct{for:do:} as shown in the following example.

\begin{code}{} 
ConfigurationOfCoolBrowser>>version09: spec 
	<version: '0.9' imports: #('0.9-baseline')>
	
	spec for: #common do: [
		...
		spec 
			package: 'CoolBrowser-Core' with: 'CoolBrowser-Core-MichaelJones.20';
			package: 'CoolBrowser-Tests' with: 'CoolBrowser-Tests-JohnLewis.8';
			package: 'CoolBrowser-Addons' with: 'CoolBrowser-Addons-JohnLewis.6' ;
			package: 'CoolBrowser-AddonsTests' with: 'CoolBrowser-AddonsTests-JohnLewis.1' ].
	
	spec for: #gemstone do: [
		spec package: 'CoolBrowser-Platform' with: 'CoolBrowser-PlatformGemstone-MichaelJones.4'.].
	spec for: #pharo do: [
		spec package: 'CoolBrowser-Platform' with: 'CoolBrowser-PlatformPharo-JohnLewis.7'.].
	spec for: #squeak do: [
		spec package: 'CoolBrowser-Platform' with: 'CoolBrowser-JohnLewis-dkh.3'.].
\end{code}

You see that the version can handle different platform.


\begin{code}{}
ConfigurationOfCoolBrowser>>baseline09: spec 
	<version: '0.9-baseline'>
	
	spec for: #common do: [
		spec blessing: #baseline.
		spec repository: 'http://www.example.com/CoolBrowser'.
		
		spec 
			package: 'CoolBrowser-Core';
			package: 'CoolBrowser-Tests' with: [ spec requires: 'CoolBrowser-Core' ];
			package: 'CoolBrowser-Addons' with: [ spec requires: 'CoolBrowser-Core' ] ;
			package: 'CoolBrowser-AddonsTests' with: [ 
				spec requires: #('CoolBrowser-Addons' 'CoolBrowser-Tests' ) ].
		spec 
			group: 'default' with: #('CoolBrowser-Core' 'CoolBrowser-Addons' );
			group: 'Core' with: #('CoolBrowser-Core' 'CoolBrowser-Platform' );
			group: 'Extras' with: #('CoolBrowser-Addon');
			group: 'Tests' with: #('CoolBrowser-Tests' 'CoolBrowser-AddonsTests' );
			group: 'CompleteWithoutTests' with: #('Core', 'Extras' );
			group: 'CompleteWithTests' with: #('CompleteWithoutTests', 'Tests' )].
			
	spec for: #gemstone do: [
		spec package: 'CoolBrowser-Platform' with: 'CoolBrowser-PlatformGemstone'.].
	spec for: #pharo do: [
		spec package: 'CoolBrowser-Platform' with: 'CoolBrowser-PlatformPharo'.].
	spec for: #squeak do: [
		spec package: 'CoolBrowser-Platform' with: 'CoolBrowser-PlatformSqueak'.].
\end{code}

Notice that we add the package \ct{CoolBrowser-Platform} in the \ct{Core} group. As you can see, we can manage this package as any other and in a unified way. Thus, we have a lot of flexibility. At runtime, when you load CoolBrowser, Metacello automatically detects in which dialect the load is happening and loads the specific package for that dialect.  	

Finally, note that the method \ct{for:do:} is not only used to specify a platform specific package, but also for anything that has to do with different dialects. You can put whatever you want from the configuration inside that block. So, for example, you can define groups, packages, repositories, etc, that are dependent on a dialect. For example, you can do this:


  \begin{code}{}
 ConfigurationOfCoolBrowser>>baseline010: spec 
	<version: '0.10-baseline'>
	
	spec for: #common do: [
		spec blessing: #baseline.].
	
	spec for: #pharo do: [
		spec repository: 'http://www.pharo.com/CoolBrowser'.
		
		spec 
			...
		spec 
			group: 'default' with: #('CoolBrowser-Core' 'CoolBrowser-Addons' );
			group: 'Core' with: #('CoolBrowser-Core' 'CoolBrowser-Platform' );
			group: 'Extras' with: #('CoolBrowser-Addon');
			group: 'Tests' with: #('CoolBrowser-Tests' 'CoolBrowser-AddonsTests' );
			group: 'CompleteWithoutTests' with: #('Core', 'Extras' );
			group: 'CompleteWithTests' with: #('CompleteWithoutTests', 'Tests' )].
			
	spec for: #gemstone do: [
		spec repository: 'http://www.gemstone.com/CoolBrowser'.
		
		spec 
			package: 'CoolBrowser-Core';
			package: 'CoolBrowser-Tests' with: [ spec requires: 'CoolBrowser-Core' ];
		spec 
			group: 'default' with: #('CoolBrowser-Core' 'CoolBrowser-Addons' );
			group: 'Core' with: #('CoolBrowser-Core' 'CoolBrowser-Platform' )].			

\end{code}	
	
In this example, for Pharo we use a different repository than for Gemstone. However, this is not mandatory, since both can have the same repository and differ in other things like versions, post and pre code executions, dependencies, etc. 

In addition, the addons and tests are not available for Gemstone, and thus, those packages and groups are not included. So, as you can see, all what we have been doing inside the \ct{for: #common: do:} can be done inside another \ct{for:do:} for a specific dialect. 


\section{Project Configuration Dependencies}
\sd{I would move that section before the property ones}

In the same way a package can depend on other packages, a project can depend on other projects. 
For example, Pier which is a CMS using meta-description depends on Magritte and Seaside. 
A project can depend completely on one or more other projects, on a group of packages of a project, or even just on one or more packages of a project. Here we have basically two scenarios depending whether the other projects is described or not using a Metacello configurations. 

\subsection{Depending on project without configuration}

A package A from a Project X depends on a package B from project Y and project Y does not have any Metacello configuration (typically when there is only one package in the project). In this case do the following:
\sd{we should use the same example A and B sucks}
\begin{code}{}
		``In the baseline method''
		spec 
			package: 'PackageA' with: [  spec requires: #('PackageB')];
			package: 'PackageB' with: [  spec repository: 'http://www.squeaksource.com/ProjectB' ].	
\end{code}

\begin{code}{}
		``In the version method''
		package: 'PackageB' with: 'PackageB-JuanCarlos.80'.
\end{code}

The problem here is that as the project B does not have a Metacello configuration, the dependencies of B are not managed. Thus, package B can have dependencies, but they will not be loaded. So, our recommendation is that in this case, you take the time to create a configuration for the project B.

\subsection{Depending on project with configuration}
Package A depends on a package or project B, but project B has also a configuration. This is the common case that we want to present now. 


To continue with our example, we introduce a new project called \ct{CoolToolSet} which uses the packages from the \ct{CoolBrowser} project. The configuration class is called \ct{ConfigurationOfCoolToolSet}. We define two packages in \ct{CoolToolSet} called \ct{CoolToolSet-Core} and \ct{CoolToolSet-Tests}. Of course, these packages depend on packages from \ct{CoolBrowser}. Let's assume for a moment that the package that contains \ct{ConfigurationOfCoolBrowser} class is called \ct{CoolBrowser-Metacello} instead of also \ct{ConfigurationOfCoolBrowser} (as we recommended). This will be better to understand each parameter. 


Let's see the first version then:

\begin{code}{}
ConfigurationOfCoolToolSet>>version01: spec 
	<version: '1.0' imports: #('1.0-baseline')>
	spec for: #common do: [
		spec 
			package: 'CoolToolSet-Core' with: 'CoolToolSet-Core-anon.1';
			package: 'CoolToolSet-Tests' with: 'CoolToolSet-Tests-anon.1'.].	
\end{code}	

\begin{code}{}
ConfigurationOfCoolToolSet >>baseline01: spec 
	<version: '0.1-baseline'>
	spec for: #common do: [
		spec repository: 'http://www.example.com/CoolToolSet'.
		spec project: 'CoolBrowser ALL' with: [
				spec 
				    className: 'ConfigurationOfCoolBrowser';
					versionString: '1.0';
					loads: #('ALL' );
					file: 'CoolBrowser-Metacello';
					repository: 'http://www.example.com/CoolBrowser' ].
		spec 
			package: 'CoolToolSet-Core' with: [ spec requires: 'CoolBrowser ALL' ];
			package: 'CoolToolSet-Tests' with: [ spec requires: 'CoolToolSet-Core' ]].
\end{code}	

\begin{figure}
\begin{center}
\includegraphics[width=0.6\linewidth]{version07}
\caption{Dependencies between configurations.\label{fig:version07}}
\end{center}
\end{figure} 

What we did here in baseline0.1 was to create a project reference for the CoolBrowser project (see Figure~\ref{fig:version07}). The \ct{className:} specifies the name of the class that contains the project metadata. If the class is not present in the image, then we need to supply all the necessary information so that Metacello can search and load the configuration for the project.

The \ct{file:} and \ct{repository:} specifications give us the information needed to load the project metadata from a repository in case the configuration class is not already present in the image. If the Monticello repository is protected, then you have to use the message: \ct{repository:username:password:}.

Note that the values for the \ct{className:} and \ct{file:} attributes are the same: \ct{'ConfigurationOfCoolBrowser'}. As we've mentioned before, by convention the name of the configuration class and the configuration package should be the same, however, with Metacello it is not required that the two be the same.

Finally, the \ct{versionString:} and \ct{loads:} tell us which version of the project to load and which packages or groups (the parameter of \ct{load:} can be the name of a package, or the name of a group or those predefined groups like 'ALL') to load from the project. \sd{should I get a version 1.0 of the version/baseline of CoolBrowser. This is not clear and I need to know that.}

We've named the project reference 'CoolBrowser ALL' and in the specification for the 'CoolToolSet-Core' package, we've specified that 'CoolBrowser ALL' is required. The name of the project reference is arbitrary, you can select the name you want, although is recommended to put a name that make sense to that project reference. \sd{why all how can I say default}
\sd{How can I say that I should load a specific version of another configurations?}

Now can now download CoolToolSet like this:

\begin{code}{}
(ConfigurationOfCoolToolSet project version: '0.1') load.
\end{code}

Note that the entire CoolBrowser project is loaded before 'CoolToolSet-Core'.

Now as is often the case, it is useful to separate the test package from the core packages for a project. So, we can write for example, the following baseline:

\begin{code}{}
ConfigurationOfCoolToolSet >>baseline02: spec 
	<version: '0.2-baseline'>
	spec for: #common do: [
		spec blessing: #baseline.
		spec repository: 'http://www.example.com/CoolToolSet'.
		spec
			project: 'CoolBrowser default' with: [
				spec
					className: 'ConfigurationOfCoolBrowser';
					versionString: '1.0';
					loads: #('default' );
					file: 'CoolBrowser-Metacello';
					repository: 'http://www.example.com/CoolBrowser' ];
			project: 'CoolBrowser Tests' with: [
				spec
					className: 'ConfigurationOfCoolBrowser';
					versionString: '1.0';
					loads: #('Tests' );
					file: 'CoolBrowser-Metacello';
					repository: 'http://www.example.com/CoolBrowser' ].
		spec 
			package: 'CoolToolSet-Core' with: [ spec requires: 'CoolBrowser default' ];
			package: 'CoolToolSet-Tests' with: [ 
				spec requires: #('CoolToolSet-Core'  'CoolBrowser Tests'  ) ].].			
\end{code}

Here we created two project references. The reference named \ct{'CoolBrowser default'} loads the 'default' group and the reference named 'CoolBrowser Tests'  loads the 'Tests' group of the configuration of Cool Browser. We then made \ct{'CoolToolSet-Core'} require \ct{'CoolBrowser default'} and \ct{'CoolToolSet-Tests'} requires \ct{'CoolToolSet-Core'} and \ct{'CoolBrowser Tests'}.

Now it is possible to load just the core packages:

\begin{code}{}
(ConfigurationOfCoolToolSet project version: '1.1') load: 'CoolToolSet-Core'.
\end{code} 
 
or the core including tests:
 
\begin{code}{}
  (ConfigurationOfCoolToolSet project version: '1.1') load: 'CoolToolSet-Tests'.
\end{code}

As you can see, in \ct{baseline02:} there is redundant information for each of the project references. To solve that situation, we can use the \ct{project:copyFrom:with:} method to eliminate the need to specify the bulk of the project information twice. Example:

\begin{code}{}
ConfigurationOfCoolToolSet >>baseline02: spec 
	<version: '0.2-baseline'>
	spec for: #common do: [
		spec blessing: #baseline.
		spec repository: 'http://www.example.com/CoolToolSet'.
		spec project: 'CoolBrowser default' with: [
				spec
					className: 'ConfigurationOfCoolBrowser';
					versionString: '1.0';
					loads: #('default' );
					file: 'CoolBrowser-Metacello';
					repository: 'http://www.example.com/CoolBrowser' ];
			project: 'CoolBrowser Tests' 
				copyFrom: 'CoolBrowser default' 
				with: [ spec loads: #('Tests').].
		spec 
			package: 'CoolToolSet-Core' with: [ spec requires: 'CoolBrowser default' ];
			package: 'CoolToolSet-Tests' with: [ 
				spec requires: #('CoolToolSet-Core' 'CoolBrowser Tests') ].].					
\end{code}

Not only in this baseline but also in baseline01 we did something that is not always useful: we put the version of the referenced projects in the baseline instead of in the version method. If you look at baseline01 or baseline02 you can see that we put \ct{versionString: '1.0'}. But sometimes, this information (the version of the referenced project) remains the same among different versions of the dependent project. 
If the referenced project is very stable this technique works very well.

On the other hand, if the referenced project will be changing over time, then  we recommend that you not specify the \ct{#versionString:} in the baseline method, but specify in the version method as follows:

\begin{code}{}
ConfigurationOfCoolToolSet >>version02: spec 
	<version: '0.2' imports: #('0.2-baseline' )>
	spec for: #common do: [
		spec blessing: #beta.
		spec 
			package: 'CoolToolSet-Core' with: 'CoolToolSet-Core-anon.1';
			package: 'CoolToolSet-Tests' with: 'CoolToolSet-Tests-anon.1';
			project: 'CoolBrowser default' with: '1.3';
			project: 'CoolBrowser Tests' with: '1.3'].
\end{code}

If we don't define a version String at all for 'CoolBrowser default'  and 'CoolBrowser Tests'  in the version method, then the version specified in the baseline will be used. If there is no version specified in the baseline method, then Metacello loads the latest version of the project.


%\section{Grouping projects} 
%
%Usually, a project has more than one package and/or the package has dependencies upon other configurations. If such is the case it is common to create a separate configuration for all those packages or projects. With this, I can reuse dependency and version information among other projects. 
%
%Maybe the sole purpose of this configuration is to group packages or projects and define stable version for them so that they can be used in different projects. 








\section{Symbolic Versions}
In any large evolving application relying on other applications and libraries, it is difficult to know which version of a configuration to use with a specific versions. This is especially true for Pharo applications where some people should maintained applications developed for a given version, while others are working on the latest build.

\ct{ConfigurationOfOmniBrowser} provides a good example of the problem: 
version 1.1.3 is used in the Pharo1.0 one-click image,  version 1.1.3 cannot be loaded into Pharo1.2,  version 1.2.3 is currently the latest \ct{development} version aimed at Pharo1.2, and version 1.2.3 cannot be loaded into Pharo1.0. 

Obviously version 1.1.3 should be used in Pharo1.0 and version 1.2.3 should be used in Pharo1.2. Now up until recently there is no way for a developer to communicate this information to his users using Metacello.

The latest version of Metacello introduces symbolic versions whose purpose is to provide a way to describe versions in terms of existing literal versions (like 1.1.3, 1.1.5 and 1.2.3). Symbolic versions are specified using the symbolic version pragma:

\begin{code}{}
OmniBrowser>>stable: spec
    <symbolicVersion: #'stable'>
    spec for: #'pharo1.0.x' version: '1.1.3'.
    spec for: #'pharo1.1.x' version: '1.1.5'.
    spec for: #'pharo1.2.x' version: '1.2.3'.
\end{code}

Symbolic versions can be used anywhere that a literal version can be used. From a load statement:
\ct{(ConfigurationOfOmniBrowser project version: #'stable') load.}
to a project reference in a baseline version:

\begin{code}{}
baseline10: spec
  <version: '1.0-baseline'>
  spec for: #squeakCommon do: [
    spec blessing: #baseline.
    spec repository: 'http://seaside.gemstone.com/ss/GLASSClient'.
    spec
      project: 'OmniBrowser' with: [
        spec
          className: 'OmniBrowser';
          versionString: #'stable';
          repository: 'http://www.squeaksource.com/MetacelloRepository' ].
    spec
       package: 'OB-SUnitGUI' with: [
         spec requires: #( 'OmniBrowser') ];
       package: 'GemTools-Client' with: [
         spec requires: #( 'OB-SUnitGUI'. ) ];
       package: 'GemTools-Platform' with: [
         spec requires: #( 'GemTools-Client'. ) ]].
\end{code}

New Platform Version Attributes

%New attributes have been added to Metacello for Pharo and Squeak to correspond to platform version numbers:
%#'pharo1.x', #'pharo1.0.x', #'pharo1.1.x', and #'pharo1.2.x'
%#'squeak3.10.x', #'squeak4.x', #'squeak4.1.x', and #'squeak4.2.x'
%These new attributes are calculated by default in Metacello based on `SystemVersion current version`. If you need a finer grain distinction for versions (say an attribute named #'pharo1.1.1') then you can change the #project method in your configuration to something like the following:

\begin{code}{}
project
  | versionString projectAttributes |
  ^ project
    ifNil: [
      "Bootstrap Metacello if it is not already loaded"
      self class ensureMetacello.
      "Construct Metacello project"
      project := (Smalltalk at: #MetacelloMCProject) new.
      projectAttributes := #().
      Smalltalk
        at: #SystemVersion
        ifPresent: [ :cl |
          versionString := cl current version.
          ((versionString beginsWith: 'Pharo-1.1.1') or: [ versionString beginsWith: 'Pharo1.1.1' ])
            ifTrue: [ projectAttributes add: #'pharo1.1.x' ] ].
      project projectAttributes: projectAttributes.
      (Smalltalk at: #MetacelloVersionConstructor) on: self project: project.
      project loadType: #linear ]
\end{code}      
      
      
   
Standard Symbolic Versions

A couple of standard symbolic versions have already been defined:

\begin{description}
\item [bleedingEdge.]  A symbolic version that specifies the latest mcz files and project versions. By default the \ct{bleedingEdge} symbolic version is defined as the latest baseline version available. The default specification for \ct{bleedingEdge} is defined for all projects. The \ct{bleedingEdge} version is primarily for developers who know what they are doing. There are no guarantees that the \ct{bleedingEdge} version will even load, let alone function correctly.

\item [development.] A symbolic version that specifies the literal version that us under development (i.e., whose blessing is \ct{development}). Typically a \ct{development} version is used by developers for managing pre-release activities as the project transitions from \ct{bleedingEdge} to \ct{stable}. There are a number of \ct{MetacelloToolBox} methods that take advantage of the \ct{development} symbolic version.

\item [stable.] A symbolic version specifies the stable literal version for a particular platform. The stable version is the version that should be used for loading.
With the exception of the \ct{bleedingEdge} version (which has a pre-defined default defined), you will need to edit your configuration to add the \ct{stable} or \ct{development} version information.
\end{description}


\section{Script and Tool Support}

\begin{code}{}   
With this release, I've added two new classes: MetacelloBaseConfiguration and MetacelloToolBox, which should make developing with Metacello and writing tools for Metacello a whole lot easier.
Development Support

The MetacelloBaseConfiguration class is aimed at eventually becoming the common superclass for all Metacello configurations, but I'm not quite ready to go there, yet. For now, though, the class serves as the location for defining the common default symbolic versions (#bleedingEdge at the present time) and as the place to find development support methods:
compareVersions - Compare the #stable version to #development version.
createNewBaselineVersion - Create a new baseline version based upon the #stable version as a model.
createNewDevelopmentVersion - Create a new #development version using the #stable version as model.
releaseDevelopmentVersion: - Release #development version: set version blessing to #release, update the #development and #stable symbolic version methods and save the configuration.
saveConfiguration: - Save the mcz file that contains the configuration to it's repository.
saveModifiedPackagesAndConfiguration: - Save modified mcz files, update the #development version and then save the configuration.
updateToLatestPackageVersions: - Update the #development version to match currently loaded mcz files.
validate - Check the configuration for Errors, Critical Warnings, and Warnings.
I suggest that you take a look at these methods and copy the methods that you find useful to the class-side of your own configuration, so that you can simplify the management of your own configuration.
Metacello Toolbox API

The MetacelloToolBox class is aimed at providing a common API for development scripts and Metacello tools. The development support methods were implemented using the Metacello Toolbox API and the OB-Metacello tools have been reimplemented to use the Metacello Toolbox API. For an overview of the Metacello Toolbox API, you can look in the HelpBrowser at the 'Metacello>>API Documentation' section. The instance-side methods for MetacelloToolBox support the  programmatic editing of Metacello configurations from the creation of a new configuration classes to the creation and changing of literal and symbolic version methods. The instance-side methods are intended for the use of Tools developers and are covered in the ProfStef tutorial: 'Inside Metacello Toolbox API'. The class-side methods for MetacelloToolBox support a number of configuration management tasks. The target the initial release of the Metacello Toolbox API is to support the basic Metacello development cycle. In addition to the following section the Metacello development cycle is covered in the ProfStef tutorial: 'Metacello Development Cycle'.
Development Cycle Walk Through

In this section we'll take a walk through a typical development cycle and provide examples of how the Metacello Toolbox API can be used to support your development process:
Example Setup
Project Startup
Create Configuration and Initial Baseline
Create Initial Literal Version
Validation
Save Initial Configuration
Development Cycle
Platform Testing
Release
Open New Version for Development
Configuration Checkpoints
Update Project Structure
and Repeat...
1.0 Example Setup

When you are developing your project and are building your configuration for the first time, you already have the packages that make up your project loaded and correctly running on your image. In this example,it is necessary to load a set of packages to simulate a image that will be used to build the first configuration of the project. We'll cheat here an use an existing configuration (ConfigurationOfGemTools) to download and install in our image all the packages and dependencies needed (just as we would have to do by hand if we were the maintainers of the project). So, don't pay much attention to this step and only focus on the fact that after evaluating it, you'll have loaded in your image all the packages needed to build the example configuration:
Gofer new
  squeaksource: 'MetacelloRepository';
  package: 'ConfigurationOfGemTools';
  load.
((Smalltalk at: #ConfigurationOfGemTools) project version: '1.0-beta.8.3')
  load: 'ALL'.
GemTools is expected to work in Squeak (Squeak3.10 and Squeak4.1) and Pharo (Pharo1.0 and Pharo1.1) and depends upon 4 other projects:
FFI
OmniBrowser
Shout
HelpSystem
GemTools itself is made up of 5 mcz files from the http://seaside.gemstone.com/ss/GLASSClient repository (note that I've made some minor structural changes to simplify the example):
OB-SUnitGUI - requires 'OmniBrowser'. in 'default' group.
GemTools-Client - requires 'OmniBrowser', 'FFI', 'Shout', and 'OB-SUnitGUI'. in 'default' group.
GemTools-Platform - requires 'GemTools-Client'. in 'default' group.
GemTools-Help - requires 'HelpSystem' and 'GemTools-Client'. in 'default' group.
2.0 Project Startup

Create Configuration and Initial Baseline
Create Initial Literal Version
Validation
Save Initial Configuration
2.1 Create Configuration and Initial Baseline

Use the toolbox API to create the initial baseline version by specifying the name, repository, projects, packages, dependencyMap and group composition:
  MetacelloToolBox
    createBaseline: '1.0-baseline'
    for: 'GemToolsExample'
    repository: 'http://seaside.gemstone.com/ss/GLASSClient'
    requiredProjects: #('FFI' 'OmniBrowser' 'Shout' 'HelpSystem')
    packages: #('OB-SUnitGUI' 'GemTools-Client' 'GemTools-Platform' 
            'GemTools-Help' )
    dependencies:
      {('OB-SUnitGUI' -> #( 'OmniBrowser' )).
      ('GemTools-Client' -> #( 'OmniBrowser' 'FFI' 'Shout' 'OB-SUnitGUI' )).
      ('GemTools-Platform' -> #( 'GemTools-Client' )).
      ('GemTools-Help' -> #( 'HelpSystem' 'GemTools-Client' )). }
    groups:
      {('default' -> #( 'OB-SUnitGUI' 'GemTools-Client' 'GemTools-Platform'
            'GemTools-Help' ))}.
The #createBaseline:... method copies the class MetacelloConfigTemplate to ConfigurationOfGemToolsExample and creates a #baseline10: method that looks like the following:
baseline10: spec
  <version: '1.0-baseline'>
  spec for: #'common' do: [
    spec blessing: #'baseline'.
    spec repository: 'http://seaside.gemstone.com/ss/GLASSClient'.
    spec
      project: 'FFI' with: [
        spec
          className: 'ConfigurationOfFFI';
          versionString: #'bleedingEdge';
          repository: 'http://www.squeaksource.com/MetacelloRepository' ];
      project: 'OmniBrowser' with: [
        spec
          className: 'ConfigurationOfOmniBrowser';
          versionString: #'stable';
          repository: 'http://www.squeaksource.com/MetacelloRepository' ];
      project: 'Shout' with: [
        spec
          className: 'ConfigurationOfShout';
          versionString: #'stable';
          repository: 'http://www.squeaksource.com/MetacelloRepository' ];
      project: 'HelpSystem' with: [
        spec
          className: 'ConfigurationOfHelpSystem';
          versionString: #'stable';
          repository: 'http://www.squeaksource.com/MetacelloRepository' ].
    spec
      package: 'OB-SUnitGUI' with: [
        spec requires: #('OmniBrowser' ). ];
      package: 'GemTools-Client' with: [
        spec requires: #('OmniBrowser' 'FFI' 'Shout' 'OB-SUnitGUI' ). ];
      package: 'GemTools-Platform' with: [
        spec requires: #('GemTools-Client' ). ];
      package: 'GemTools-Help' with: [
        spec requires: #('HelpSystem' 'GemTools-Client' ). ].
    spec group: 'default' with: #('OB-SUnitGUI' 'GemTools-Client'
          'GemTools-Platform' 'GemTools-Help' ). ].
Note that for the 'FFI' project the versionString is #bleedingEdge, while the versionString for the other projects is #'stable'. At the time of this writing the FFI project did not have a #stable symbolic version defined, so the default versionString is set to #bleedingEdge. If a #stable symbolic version is defined for the project, the the default versionString is #stable. There are no special version dependencies for the GemTools project so the defaults will work just fine.
2.2 Create Initial Literal Version

Now we use the toolbox API to create the  initial literal version of the project. This toolbox method bases the definition of the literal version on the baseline version that we created above and uses the currently loaded state of the image to define the project versions and mcz file versions:
  MetacelloToolBox
    createDevelopment: '1.0'
    for: 'GemToolsExample'
    importFromBaseline: '1.0-baseline'
    description: 'initial development version'.
The #createDevelopment:... method creates a #version10: method in your configuration that looks like this:
version10: spec
  <version: '1.0' imports: #('1.0-baseline' )>
  spec for: #'common' do: [
    spec blessing: #'development'.
    spec description: 'initial development version'.
    spec author: 'dkh'.
    spec timestamp: '1/12/2011 12:29'.
    spec 
      project: 'FFI' with: '1.2';
      project: 'OmniBrowser' with: #'stable';
      project: 'Shout' with: #'stable';
      project: 'HelpSystem' with: #'stable'.
    spec
      package: 'OB-SUnitGUI' with: 'OB-SUnitGUI-dkh.52';
      package: 'GemTools-Client' with: 'GemTools-Client-NorbertHartl.544';
      package: 'GemTools-Platform' with: 'GemTools-Platform.pharo10beta-dkh.5';
      package: 'GemTools-Help' with: 'GemTools-Help-DaleHenrichs.24'. ].
Note that when the #stable symbolic version specifications were carried through into the literal version. If the version isn't #stable, then the currentVersion of the project is filled in, just as the current version of each mcz file is set for the packages. Note also that the blessing of the version '1.0' is set to #development. By setting the blessing of a newly created version to #development, you indicate that the version is under development and is subject to change without notice. The #createDevelopment:... method also creates a #development: method and specifies that version '1.0' is a #development symbolic version:
development: spec
  <symbolicVersion: #'development'>
  spec for: #'common' version: '1.0'.
2.3 Validation

Whenever you finish editing a configuration you should validate it to check for mistakes that may cause problems later on:
(MetacelloToolBox validateConfiguration: ConfigurationOfGemToolsExample) explore.
If the list comes back empty then you are clean. Otherwise you should address the validation issues that show up. Validation issues are divided into three categories:
Warning - issues that point out oddities in the definition of a version that do not affect behavior.
Critical Warning - issues that identify inconsistencies in the definition of a version that may result in unexpected behavior.
Error - issues that identify explicit problems in the definition of a version that will result in errors if an attempt is made to resolve the version.
Here's an example of a Critical Warning validation issue:
Critical Warning: No version specified for the project reference 'OCompletion'
            in version '1.1'
    { noVersionSpecified }
    [ ConfigurationOfOmniBrowser #validateVersionSpec: ]
The first and second line is the explanation, a human readable error message. The third line is the reasonCode, a symbol that represents the category of the issue. You can check out the meanings of the various reasonCodes online or through the following toolbox call:
(MetacelloToolBox descriptionForValidationReasonCode: #noVersionSpecified)
    inspect.
The fourth line lists the configurationClass, the configuration that spawned the issue (there is a different toobox method for running a recursive configuraiont validation) and the callSite, which is the name of the validation method that generated the error (this is used mainly for debugging).
2.4 Save Initial Configuration

The first time you save your configuration, you have to decide where to keep your configuration. It makes sense to keep the configuration in your development repository. The first time that you save your configuration you need to use the MonticelloBrowser or an expression like the following:
  Gofer new
    url: 'http://www.example.com/GemToolsRepository';
    package: 'ConfigurationOfGemToolsExample';
    commit: 'Initial version of configuration'.
3.0 Development Cycle

Platform Testing
Release
Open New Version for Development
Configuration Checkpoints
Update Project Structure
and Repeat...
3.1 Platform Testing

To finish the validation of your configuration, you need to do some test loads on your intended platforms. For GemTools I generally do a test load into a fresh image (each of the supported PharoCore and Squeak4.1) with the following load expression:
Gofer new
  url: 'http://www.example.com/GemToolsRepository';
  package: 'ConfigurationOfGemToolsExample';
  load.
((Smalltalk at: #ConfigurationOfGemToolsExample)
    project version: #development) load.
and then run the unit tests. Note that for the GemTools unit tests you need to have GemStone installed.
3.2 Release

Once you are satisfied that the configuration loads correctly on your target platforms, you can release the #development into production using the following expression:
  MetacelloToolBox
    releaseDevelopmentVersionIn: ConfigurationOfGemToolsExample
    description: '- release version 1.0'.
The toolbox method #releaseDevelopmentVersionIn:description: does the following:
set the blessing of the #development  version to #release
sets the #development  version to #notDefined
sets the #stable  version to the literal version of the #development version (in this case '1.0')
saves the configuration mcz file to the correct repository
The #development: method ends up looking like this:
development: spec
  <symbolicVersion: #'development'>
  spec for: #'common' version: #'notDefined'.
The #stable: method ends up looking like this:
stable: spec
  <symbolicVersion: #'stable'>
  spec for: #'common' version: '1.0'.
Finally you can copy the configuration to the MetacelloRepository using the following expression:
  MetacelloToolBox
    copyConfiguration: ConfigurationOfGemToolsExample
    to: 'http://www.squeaksource.com/MetacelloRepository'.
3.3 Open New Version for Development

MetacelloToolBox
  createNewDevelopmentVersionIn: ConfigurationOfGemToolsExample
  description: '- open 1.1 for development'.
3.4 Configuration Checkpoints

During the course of development it makes sense to save checkpoints of your development to your repository. To setup this example you should load a newer version of GemTools and get some new mcz files loaded to simulate development:
(ConfigurationOfGemTools project version: '1.0-beta.8.4')
  load: 'ALL'.
Now that you've simulated some development you can update the #development version of your project so that it references the new mcz files you've loaded
MetacelloToolBox
  updateToLatestPackageVersionsIn: ConfigurationOfGemToolsExample
  description: '- fixed Issue 1090'.
Then save the configuration to your repository:
MetacelloToolBox
  saveConfigurationPackageFor: 'GemToolsExample'
  description: '- fixed Issue 1090'.
Or do both steps with one toolbox method:
MetacelloToolBox
  saveModifiedPackagesAndConfigurationIn: ConfigurationOfGemToolsExample
  description: '- fixed Issue 1090'.
3.5 Update Project Structure

In the course of development it is sometimes necessary to add a new package or reference and addition project. In this case let's add a package to the project called 'GemTools-Overrides' ('GemTools-Overrides' is actually part of the GemTools project already and I just left it out of the previous example). To add a new package a project you need to:
create a new baseline version to reflect the new package and dependencies
update existing #development version to reference the new baseline version and include the explicit version for the new package
You can do that manually by using a class browser to manually:
copy and edit the old baseline version to reflect the new structure
edit the existing #development version method
Or you can use the Metacello Toolbox API (not finished/tested yet:):
| toolbox |
toolbox := MetacelloToolBox configurationNamed: 'GemToolsExample'.
toolbox
  createVersionMethod: 'baseline11:' inCategory: 'baselines' forVersion: '1.1-baseline';
  addSectionsFrom: '1.0-baseline'
    forBaseline: true
    updateProjects: false
    updatePackages: false
    versionSpecsDo: [ :attribute :versionSpec |
      attribute == #common
        ifTrue: [ versionSpec packages add: (toolbox createPackageSpec: 'GemTools-Overrides') ].
      true ];
  commitMethod;
  modifyVersionMethodForVersion: '1.1'
    versionSpecsDo: [ :attribute :versionSpec |
      attribute == #common
        ifTrue: [ versionSpec packages add: (toolbox createPackageSpec: 'GemTools-Overrides') ].
      false ];
  commitMethod.
\end{code}


\end{document}

\section{Symbolic Versions}
From the beginning Metacello has had the notion of loading the latest version. The expectation was that loading the latest release would
always be the best thing to do.

As Pharo has moved forward, aggressively cleaning up the base image, it has turned out that loading the latest version isn't always the
best solution: code that runs in Pharo1.0 won't work in Pharo1.2 and vice versa.

To solve this problem we need to be able to describe the 'latest version' on a platform by platform basis. 'latest version' is only one of the dimensions that we're interested in. At this point in time, there are really three version dimensions that are interesting:

\begin{description}
\item \ct{bleedingEdge} -- the latest mcz file defined in the latest baseline
for a
                       project.
\item  \ct{development} -- the currently active development version
\item  \ct{stable}      -- what we really want when we say 'latest version'

\end{description}


It may happen that over time there will be additional dimensions over time.
For Metacello for example we could imagine \ct{earlyAccess} versions which are \ct{'stable'} development versions.

The requirement is to be able to declare a \ct{stable} or \ct{development} version on a platform by platform basis. 
To do so there are two additional pragmas that can be included in Configuration class methods:

\begin{code}{}
 <symbolicVersion: SYMBOLIC_VERSION_SYMBOL>
 <defaultSymbolicVersion: SYMBOLIC_VERSION_SYMBOL>
\end{code}

The \ct{symbolicVersion:} pragma is similar to the version pragma (\ct{<version: VERSION_STRING>}). 
A symbolic version may be used anywhere that a literal version may be used.
The following is an example where a set
of \ct{stable symbolic} versions are declared:

\begin{code}{}
 stable: spec
	<symbolicVersion: #'stable'>

	spec for: #'common' version: '1.0.2.1'.
	spec for: #'pharo1.0.x' version: '1.0.2.1'.
	spec for: #'pharo1.1.x' version: '1.0.3'.
	spec for: #'pharo1.2.x' version: '1.0.4'.
\end{code}

The \ct{defaultSymbolicVersion:} is used in a method that is expected to be regular smalltalk code that returns a version string. The following is the definition for the \ct{bleedingEdge} symbolic version: \sd{not sure that it is ok to show here}

\begin{code}{}
bleedingEdge
	<defaultSymbolicVersion: #bleedingEdge>

	| bleedingEdgeVersion |
	bleedingEdgeVersion := (self project map values select: [ :version |
version blessing == #baseline ])
		detectMax: [ :version | version ].
	bleedingEdgeVersion ifNil: [ bleedingEdgeVersion := self project
latestVersion ].
	bleedingEdgeVersion
		ifNil: [ self versionDoesNotExistError: #bleedingEdge ].
	^ bleedingEdgeVersion versionString
\end{code}

When specifying a symbolic version with a \ct{symbolicVersion:} pragma it is legal to use another symbolic version like the following definition for the symbolic version \ct{stable}:

\begin{code}{}
stable: spec
	<symbolicVersion: #'stable'>

	spec for: #'gemstone' version: '1.5'.
	spec for: #'squeak' version: '1.4'.
	spec for: #'pharo1.0.x' version: '1.5'.
	spec for: #'pharo1.1.x' version: '1.5'.
	spec for: #'pharo1.2.x' version: #development.
\end{code}

Or to use the special symbolic version \ct{notDefined}: as in the following definition of the symbolic version \ct{development}:

\begin{code}{}
development: spec
	<symbolicVersion: #'development'>

	spec for: #'common' version: #notDefined.
	spec for: #'pharo1.1.x' version: '1.6'.
	spec for: #'pharo1.2.x' version: '1.6'.
\end{code}

Here this indicates that there are no version for the \ct{common} tag. 
Using a symbolic version that resolves to \ct{notDefined} will result in a \ct{MetacelloSymbolicVersionNotDefinedError} being signaled.
\section{Load types}
Metacello lets you specify the way packages are loaded through its ``load types''. For the time of this writing, there are only two possible load types: \emph{atomic} and \emph{linear}. 

Atomic loading is used where packages have been partitioned in such a way that they can't be loaded individually. The definitions from each package are munged together into one giant load by the Monticello package loader. Class side \ct{initialize} methods and pre/post code execution are performed for the whole set of packages, not individually. 

If you use a linear load, then each package is loaded in order. Class side \ct{initialize} methods and pre/post code execution are performed just before or after loading that specific package.

It is important to notice that managing dependences does not imply the order packages will be loaded. That a package \emph{A} depends on package \emph{B} doesn't mean that B will be loaded before \emph{A}. It just guarantees that if you want to load \emph{A}, then \emph{B} will be loaded too. 

A problem with this happens also with methods override. If a package overrides a method from another package, and the order is not preserved, then this can be a problem because we are not sure the order they will load, and thus, we cannot be sure which version of the method will be finally loaded. 

When using atomic loading the package order is lost and we have the mentioned problems. However, if we use the linear mode, then each package is loaded in order. Moreover, the methods override should be preserved too. 

A possible problem with linear mode is the following: suppose project \emph{A} depends has dependencies on other two projects \emph{B} and \emph{C}. \emph{B} depends on the project \emph{D} version 1.1 and \emph{C} depends on project \emph{D} version 1.2 (the same project but another version). First question, which \emph{D} version does \emph{A} have at the end?  By default (you can change this using the method \ct{operator:} in the \ct{project} method), Metacello will finally load version 1.2.

However, and here is the relation with load types, in atomic loading \emph{only} 1.2 is loaded. In linear loading, \emph{both} versions may (depending on the dependency order) be loaded, although 1.2 will be finally loaded. But this means that 1.1 may be loaded first and then 1.2. Sometimes this can be a problem because an older version of a package or project may not even load in the Pharo image we are using. 

For all the mentioned reasons, the default mode is linear. Users should use atomic loading in particular cases and when they are completely sure. 

Finally, if you want to explicitly set a load type, you have to do it in the \ct{project} method. Example:

\begin{code}{}
ConfigurationOfCoolToolSet >>project

	^ project ifNil: [ | constructor |
		"Bootstrap Metacello if it is not already loaded"
		self class ensureMetacello.
		"Construct Metacello project"
		constructor := (Smalltalk at: #MetacelloVersionConstructor) on: self.
		project := constructor project.
		project loadType: #linear. '"or #atomic'"
		project ]

\end{code}

\section{Project definition}

We have already explained that the easiest way to create a configuration class is to copy the existing MetacelloConfigTemplate class. If we now take a deeper understanding of such class, we can see that it implements the method \ct{project}. In case you did not notice, we have used this method everywhere along this chapter. For example, we have used it to load a version:

\begin{code}{}
  (ConfigurationOfCoolToolSet project version: '1.1') load: 'CoolToolSet-Tests'.
\end{code}

In this method \ct{project} you can specify and customize your project definitions. For example, you can specify the Metacello constructor, the load type, project attributes, etc. Later in this chapter we will go a little deeper with some of these topics. This is a typical implementation of \ct{project} method: 
\sd{check the latest code}
\begin{code}{}
ConfigurationOfCoolToolSet >>project

	^ project ifNil: [ | constructor |
		"Bootstrap Metacello if it is not already loaded"
		self class ensureMetacello.
		"Construct Metacello project"
		constructor := (Smalltalk at: #MetacelloVersionConstructor) on: self.
		project := constructor project.
		project loadType: #linear.
		project ]

\end{code}


\section{Conditional loading}
When loading a project, usually the user wants to decide whether to load or not certain packages depending on a specific condition, for example, the existence of certain other packages in the image. Suppose you want to load Seaside (or any other web framework) in your image. Seaside has a tool that depends on OmniBrowser and it is used for managing instances of web servers. What can be done with this little tool can also be done by code. If you want to load such tool you need OmniBrowser. However, other users may not need such package. An alternative could be to provide different groups, one that includes such package and one that does not. The problem is that the final user should be aware of this and load different groups in different situations.  With conditional loading you can, for example, load that Seaside tool only if OmniBrowser is present in the image. This will be done automatically by Metacello and there is no need to explicitly load a particular group. 

Suppose that our CoolToolSet starts to provide much more features. We first split the core in two packages: 'CoolToolSet-Core' and 'CoolToolSet-CB'. CoolBrowser can be present in one image but not in another one. We want to load the package 'CoolToolSet-CB' by default only and if CoolBrowser is present. 

The mentioned conditionals are achieved in Metacello by using the \emph{project attributes} we saw in the previous section. They are defined in the \ct{project} method. 
\sd{to me it looks really bad and I'm sure that we want to document that}
Example:


\begin{code}{}
ConfigurationOfCoolBrowser >>project
	|  | 
	^ project ifNil: [ | constructor |
		"Bootstrap Metacello if it is not already loaded"
		self class ensureMetacello.
		"Construct Metacello project"
		constructor := (Smalltalk at: #MetacelloVersionConstructor) on: self.
		project := constructor project.
		projectAttributes :=  ((Smalltalk at: #CBNode ifAbsent: []) == nil
			ifTrue: [ #( #'CBNotPresent' ) ]
			ifFalse: [ #( #'CBPresent' ) ]).
		project projectAttributes:  projectAttributes.
		project loadType: #linear.
		project ]

\end{code}

As you can see in the code, we check if CBNode class (a class from CoolBrowser) is present and depending on that we set an specific project attribute.
This is flexible enough to let you define your own conditions and set the amount of project attributes you wish (you can define an array of attributes).  
Now the questions is how to use these project attributes. In the following baseline we see an example:

\begin{code}{}
ConfigurationOfCoolToolSet >>baseline02: spec 
	<version: '0.2-baseline'>
	
	spec for: #common do: [
		spec blessing: #baseline.
		spec repository: 'http://www.example.com/CoolToolSet'.
		spec project: 'CoolBrowser default' with: [
				spec
					className: 'ConfigurationOfCoolBrowser';
					versionString: '1.0';
					loads: #('default' );
					file: 'CoolBrowser-Metacello';
					repository: 'http://www.example.com/CoolBrowser' ];
			project: 'CoolBrowser Tests' 
				copyFrom: 'CoolBrowser default' 
				with: [ spec loads: #('Tests').].
		spec 
			package: 'CoolToolSet-Core';
			package: 'CoolToolSet-Tests' with: [ 
				spec requires: #('CoolToolSet-Core') ];
			package: 'CoolToolSet-CB';			
		spec for: #CBPresent do: [
			spec
				group: 'default' with: #('CoolToolSet-CB' )
				yourself ].
		spec for: #CBNotPresent do: [
			spec 
				package: 'CoolToolSet-CB' with: [ spec requires: 'CoolBrowser default' ];
				yourself ].
			].
		
\end{code}

You can notice that the way to use project attributes is through the existing method \ct{for:do:}. Inside that method you can do whatever you want: define groups, dependencies, etc. In our case, if CoolBrowser is present, then we just add 'CoolToolSet-CB' to the default group. If it is not present, then 'CoolBrowser default' is added to dependency to 'CoolToolSet-CB'. In this case, we do not add it to the default group because we do not want that. If desired, the user should explicitly load that package also. 

Again, notice that inside the \ct{for:do:} you are free to do whatever you want.




%%% Local Variables: 
%%% coding: utf-8
%%% mode: latex
%%% TeX-master: Lint.tex
%%% TeX-PDF-mode: t
%%% End:
