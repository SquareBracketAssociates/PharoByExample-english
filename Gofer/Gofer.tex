% $Author: jannik $
% $Date: 2010-05-13 23:11:04 +0200 (Thu, 13 May 2010) $
% $Revision: 32942 $

% HISTORY:
% 2010-05-14 - Jannik started chapter

%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6.13in,9.21in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\pagestyle{headings}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
	% \renewcommand{\nnbb}[2]{} % Disable editorial comments
	\sloppy
\fi
%=================================================================

%=================================================================


\chapter{Gofer: Scripting package loading}

Pharo proposes powerful tools to manage source code such as semantics-based merging, three diff-merge, and a git-like distributed versioning system. In particular as presented in the Monticello Chapter, Pharo uses a package system named Monticello. In this chapter after a first reminder of the key aspects of Monticello we will show how we can script package using Gofer. Gofer is a simple API for Monticello. It is used by Metacello, the language to manage package maps that we present in Chapter Metacello. 



\section{Preamble: Package management system}

\paragraph{Packages.}
A package is a list of class and method definition. In Pharo a package is not associated with a namespace. A package can extend class defined in other package: it measn that a package, for example \ct{Network} can add methods to the class \ct{String}, eventhough \ct{String} is not defined in the package \ct{Network}. Class extensions support the definition of layers and allows for the natural definition of packages. 


\begin{figure}
\begin{center}\includegraphics[width=6cm]{classExtension}\end{center}
\end{figure}

To define a package, you simply need to declare one using the Monticello browswer and to define a class extensions, it is enough to define a method with a category starting with '*' followed by the package name (here \ct{'*-network'}). 

\begin{code}{}
Object subclass: #ButtonsBar
    instanceVariableNames: ''
    classVariableNames: ''
    poolDictionaries: ''
    category: 'Zork'
\end{code}    


\begin{figure}
\begin{center}
\includegraphics[width=8cm]{browserExtension}
\caption{The browser O2 shows that the class \ct{String} gets the methods \ct{asUrl} and \ct{asUrlRelativeTo:} from the package \ct{network-url}}
\end{center}
\end{figure}

We can get the list of changes of package before publication by simply selecting the package and clicking on the \button{Changes} of the Monticello Browser. 


\begin{figure}
\begin{center}
\includegraphics[width=8cm]{changeBrowser}
\end{center}
\end{figure}

\paragraph{Package Versioning System.}
A version management system helps for version storage and keeps an history of system evolution. Moreover, it provides the management of concurrent accesses to a source code repository. It keep traces of all saved changes and allows us to collaborate with other engineers. More a project grows, more it is important to use a version management system.

Monticello defines the package system and version management of Pharo. In Pharo, classes (superclass change, instance variable changes \ldots) and methods (adding, changing, deleting) are elementary entities which are versioned by Monticello. A source is an HTTP server which allows us to save projects (particularly packages) managed by Monticello. This is the equivalent of a forge: It provides the management of contributors and their status, visibility information, a wiki with RSS feed. A source open to everybody est available at \url{http://www.squeaksource.com/}.


\paragraph{Distributed architecture of Monticello.} Monticello is a distributed version control management system like git but dedicated to Smalltalk. Monticello manipulates source code entities such as classes, methods,... It is then possible to manage local and distributed code servers. Gofer allows one to script such servers to publish, download and synchronize servers. 


Monticello uses a local cache for packages. Each time a package is required, it is first looked up in this local cache. In a similar way, when a package is saved, it is also saved in the local cache.  From a physical point of a view a Monticello package is a zipped file containing meta-data and the complete source code of package. 
To be clear in the following we make the distinction between a package loaded in the pharo image and a package saved in the cache but not loaded. We also define the following terms: image (object and bytecode executed by the virtual machine), loaded package (downloaded package from a server that is loaded in memory), dirty package (a loaded package with unsaved modifications). A dirty package is a loaded package.

For example, in Figure~\ref{fig:archi} the package \ct{a.1} is loaded from the server squeaksource. It is not modified. The package \ct{b.1} is loaded from the server yoursource.com but it is modified locally in the image.
Once \ct{b.1} which was dirty is saved on the server yoursource.com, it is versioned into \ct{b.2} which is saved in the cache and the remote server. 


\begin{figure}
\begin{center}
\includegraphics[width=7cm]{Architecture3}
\caption{(left)Typical setup with clean and dirty packages loaded and cached  --- (right) Package published. \label{fig:archi}}
\end{center}
\end{figure}


%\begin{figure}
%%\begin{center}
%\includegraphics[width=7cm]{Architecture2}
%\end{center}
%\end{figure}






\section{What is Gofer?}
Gofer is a scripting tool for Monticello. It is developed by Lukas Renggli and it is used by Metacello (the map and project management system built on top of Monticello). Gofer supports the easy creation of scripts to load, save, merge, update, fetch ... packages. In addition, Gofer makes sure that operations let the system in a clean state. Gofer allows one to load packages located in different repositories in a single operation, to load the latest stable version or the currently developed version. Gofer is part of basis of Pharo since Pharo 1.0.
Metacello uses Gofer as its underlying infrastructure to load complex projects. Gofer is more adapted to load simple package. 

You can ask Gofer to update it itself by executing the following expression: 

\begin{code}{}
Gofer gofer update
\end{code}

\section{Using Gofer}
Using Gofer is simple: you need to specify a location, the package to be loaded and finally the operation to be performed. The location often represents a file system been it an HTTP, a FTP or simply an hard-disc.   The location is the same as the one used to access a Monticello repository.For example it is  \ct{'http://www.squeaksource.com/MyPackage'} as used in the following expression. 

\begin{code}{A}
MCHttpRepository 
    location: 'http://www.squeaksource.com/MyPackage'
    user: 'pharoUser' 
    password: 'pharoPwd'
\end{code}

Here is a typical Gofer script: it says that we want to load the package \ct{GoferLinuxMag} from the repository \ct{GoferLinuxMag} that is available on \ct{http://www.squeaksource.com}.


\begin{code}{}
Gofer new
    url: 'http://www.squeaksource.com/GoferLinuxMag'	
    package:'GoferLinuxMag';
	load
\end{code}

When the repository (HTTP or FTP) requires an identification, the message \ct{url:username:password:} is available.  The message \ct{directory:} supports the access to local files. 
Since we often use the same public servers, there are some shortcuts in the API to use them. For example, \ct{squeaksource:} is a shortcut for \ct{http://www.squeaksource.com}, \ct{wiresong:} for \ct{http://source.wiresong.ca/} and \ct{gemsource:} for \ct{http://seaside.gemstone.com/ss/}.
In such a case you do not need to specify the full path as shown with the next snippet:

\begin{code}{}
Gofer new
    squeaksource: 'GoferLinuxMag';
    package: 'GoferLinuxMag'; 
    load
\end{code}




\begin{code}{}
Gofer new
    "on travaille sur le projet GoferLinuxMag"
    url: 'http://www.squeaksource.com/GoferLinuxMag'	
    "on spécifie un nom d'utilisateur"
    username: 'pharoUser'
    "on spécifie un mot de passe" 
    password: 'pharoPwd'; 
    "on ajoute le package souhaité"
    package:'GoferLinuxMag'; 
    "on désactive la recherche dans la cache local"
    disablePackageCache; 
    "on désactive les erreurs de répertoire"
    disableRepositoryErrors; 
    "on charge les packages spécifiés"
    load.
"on exécute la commande open"
(Smalltalk at: #ButtonsBar) open.
\end{code}







En supplément, Gofer déclare par défaut le répertoire local de cache comme une URL. Dans le cas où Gofer n'arriverait pas à charger un package dans l'URL spécifié, il va donc chercher dans le répertoire « cache » à la racine de Pharo. Il est possible de désactiver cette option en utilisant la méthode « disablePackageCache » ou de la réactiver en utilisant la méthode « enablePackageCache ».

De la même manière, Gofer retourne une erreur si l'un des répertoires n'est pas joignable. Pour ignorer ces erreurs, il suffit d'utiliser la méthode « disableRepositoryErrors ». Pour réactiver cette fonctionnalité, il suffit d'utiliser la méthode « enableRepositoryErrors ».


Ce code charge un ensemble de boutons permettant chacun de charger des projets différents. Vous pouvez regarder le code, le modifier ou en ajouter. Le résultat du message « open » donne la figure suivante:




%/// Image : resultButtonsBar.png ///

Nous vous encourageons à modifier ce projet avec des scripts différents, et à profiter de l'API de Gofer pour gérer vos sources délocalisée.

\subsection{Specify package}

Une fois l'URL spécifiée et les options définies, on spécifie le ou les packages sur lesquels on souhaite travailler. Pour cela on utilise la méthode « version: » pour travailler sur une version particulière du package, ou la méthode « package: » pour travailler sur la dernière version du package dans l'ensemble des répertoires donnés. 

Il est également possible de spécifier des contraintes de chargement de packages. La méthode « package:constraint: » permet de passer un block en paramètre pour définir certaines conditions.

Par exemple, le code suivant permet de récupérer la dernière version du package «GoferLinuxMag» sauvegardée par le développeur nommé « jannik.laval ».

\begin{code}{}
Gofer new
    squeaksource: 'GoferLinuxMag';
    package: 'GoferLinuxMag' constraint: [ :version | version author = 'jannik.laval' ];
    load
\end{code}
Un deuxième exemple qui récupère la version 2 du package «GoferLinuxMag»:
\begin{code}{}
Gofer new
    squeaksource: 'GoferLinuxMag';
    version: 'GoferLinuxMag-jannik_laval.2';
    load
\end{code}

\subsection{Do actions}
%Une fois l'instance de Gofer paramétré, nous pouvons faire de multiple manipulations. Dans ce paragraphe, nous listons les actions possibles suivies d'une courte description. Certaines seront détaillées plus loin dans l'article.
%
%load
%charge les packages spécifiés dans Pharo
%update
%met à jour les versions locales des packages
%merge
%fusionne la version distante avec la version local des packages
%localChanges
%affiche la liste des changements entre la version de base et la version en cours de modification
%remoteChanges
%affiche les changements entre la version en cours et la version distante.
%cleanup
%nettoie les packages spécifiés: il efface les catégories inutiles du package.
%commit / commit:
%sauvegarde les packages sur le serveur distant spécifié. La deuxième méthode permet d'ajouter un message de log.
%revert
%réinitialise les packages dans leur dernières versions chargées
%recompile
%recompile les package
%unload
%supprime de Pharo les packages spécifiés
%fetch
%charge les packages depuis des répertoires distants dans le répertoire local
%push
%sauvegarde les versions de package locales dans le répertoire distant

\subsection{Installing a package}

%Comme nous l'avons évoqué dans les paragraphes précédents, on peut utiliser Gofer pour charger une version spécifique d'un package, charger la dernière version sauvegardée sur le serveur distant, ou encore  charger la dernière version sauvegardé par un programmeur particulier:
%Gofer new
%    "on travaille sur le projet Seaside sauvegardé sur le serveur Squeaksource "
%    squeaksource: 'MetacelloRepository';
%    "on traite la dernière version du package sauvegardé" 
%    package: 'ConfigurationOfSeaside30'; 
%    load	
%"Cette dernière ligne permet de charger le code source de Seaside30"
%(Smalltalk at: #ConfigurationOfSeaside30) load.
%Attention cette action va charger tout Seaside (quelques 70 packages dans votre système), cela prend un certain temps, nous vous suggérons de ne pas le faire immédiatement.

\subsection{\ldots or several}
%Nous pouvons spécifier le chargement de plusieurs packages provenant de plusieurs serveurs différents grâce à Gofer. Le code ci-dessous est à exécuter après celui chargeant Seaside (code précédent). Il charge différents packages provenant de deux serveurs différents. La séquence de chargement est respectée: le script charge dans l'ordre Pier-All, Picasa-Model et Picasa-Seaside.
%Gofer new 		
%    renggli: 'pier';
%    package: 'Pier-All';
%    squeaksource: 'PicasaClient';
%    package: 'Picasa-Model';
%    package: 'Picasa-Seaside';
%    load.
%Cet exemple semble montrer que Pier-All est cherché dans le répertoire Pier de du serveur « renggli », et que Picasa-Model et Picasa-Seaside sont cherchés dans le répertoire PicasaClient de SqueakSource. Or, en réalité, Gofer ne prend pas en compte cet ordre. L'ensemble des packages sont cherchés dans les deux répertoires. En l'absence de numéro de version, le script chargera le package le plus récent sur l'ensemble des deux serveurs.
%On peut donc écrire le script de cette façon:
%Gofer new 
%    squeaksource: 'PicasaClient';		
%    renggli: 'pier';
%    package: 'Pier-All';
%    package: 'Picasa-Model';
%    package: 'Picasa-Seaside';
%    load.
%Dans certains cas, nous souhaitons spécifier une source particulière pour un package. Dans ce cas, nous créons plusieurs script, comme ceci:
%Gofer new
%    squeaksource: 'PicasaClient';
%    package: 'Picasa-Model';
%    package: 'Picasa-Seaside';
%    load.
%Gofer new
%    squeaksource: 'PicasaClientLightbox';
%    package: 'Picasa-Model';
%    package: 'Picasa-Seaside';
%    load.
%Notez que ces scripts chargent les dernières versions des packages, donc ils sont fragiles car si une personne publie un nouveau package avec un bug vous allez le charger. Spécifier la version est une façon de se protéger des changements que l'on ne contrôle pas. 

\subsection{Other protocols}

%Gofer offre également le protocole FTP et la recherche dans le répertoire local. Pour cela nous utilisons les mêmes commandes que les scripts précédents à quelques différences près.
%Pour FTP, nous spécifions l'url précédée de l'entête ftp://
%Gofer new
%    url: 'ftp://wtf-is-ftp.com/code';
%    ...
%Pour un répertoire local, nous utilisons la commande « directory: » suivi du chemin absolu du répertoire contenant les fichiers à charger.
%Gofer new
%    directory: '/home/jlaval/repository';
%    ...
%Pour finir, il est possible de chercher les fichiers dans le répertoire et tous ces sous-répertoires en utilisant « * »
%Gofer new
%    directory: '/home/jlaval/repository/*';
%    ...

\subsection{Synchronizing with a remote server}

%Lorsque l'on travaille avec un package chargé depuis un serveur distant, il est important de synchroniser les versions. La synchronisation fonctionne dans les deux sens: « serveur vers client » pour mettre à jour la version locale, « client vers serveur » pour sauvegarder le travail effectué.
%Dans une partie précédente, nous avons utilisé particulièrement la commande « load » correspondant au sens « serveur vers client ». L'utilisation des autres commandes est similaire: définition d'une URL, définition d'un projet, opération à exécuter.

\paragraph{Merge, update and revert}

%La commande « merge » permet de fusionner la version distance avec la version en cours de travail, en modifiant la version locale. Si il y a des conflits entre les deux versions, une fenêtre s'affiche pour laisser le choix à l'utilisateur. Dans le cas contraire, la fusion se fait en silence.
%Gofer new
%    squeaksource: 'GoferLinuxMag';
%    package: 'GoferLinuxMag';
%    merge
%La commande « update », quant à elle, met à jour le ou les packages spécifiés de la machine locale avec la version du serveur distant. Cette commande efface les modifications effectuées en locale et non-sauvegardée.
%La commande « revert » met à l'état initial la version locale. En quelques mots, elle charge une nouvelle fois la version précédemment chargée. Elle efface dons les modifications effectuées par l'utilisateur.

\paragraph{commit and commit:}

%Maintenant qu'on a appris à créer un script pour installer un package et manipuler le code en local, on peut sauvegarder les informations sur le serveur. Cette fonctionnalité est assurée par deux méthodes: « commit » et « commit: ». La première sauvegarde sans laisser de commentaires, la seconde prend une chaine de caractère en paramètre pour commenter la version sauvegardée.
%Gofer new
%    " on sauvegarde le packages dans le répertoire GoferLinuxMag "
%    squeaksource: 'GoferLinuxMag';
%    package: 'GoferLinuxMag';
%
%    " on commente les changements effectué, et on sauvegarde "
%    commit: 'changed a lot of things'
%Dans le cas d'une sauvegarde, il est important de travailler sur la dernière version du projet. Souvent lorsque plusieurs développeurs travaillent sur le même projet, les versions locales ne sont pas à jour. Une solution pour palier ce problème au moment de la sauvegarde est de fusionner les dernières versions avant de sauvegarder. Voici un exemple:
%Gofer new
%    " on sauvegarde le packages dans le répertoire GoferLinuxMag "
%    squeaksource: 'GoferLinuxMag';
%    package: 'GoferLinuxMag';
%
%    "on s'assure de travailler avec la dernière version du package "
%    merge;
%
%    "on commente les changements effectué, et on sauvegarde "
%    commit: 'changed a lot of things'

\paragraph{localChanges and remoteChanges}

%Parfois avant de charger une nouvelle version du package ou de sauvegarder, il peut être utile de regarder les changements effectués en local ou sur le serveur. Pour cela les méthodes « localChanges » et « remoteChanges » permettent pour la première d'afficher les changements entre la dernière version téléchargée et la version en cours de modification ; pour la seconde d'afficher les changements entre la version en cours et la dernière version sauvegardée sur le serveur distant. Ces deux méthodes retournent une liste de changements.
%Gofer new
%    squeaksource: 'GoferLinuxMag';
%    "on ajoute la dernière version de GoferLinuxMag"
%    package: 'GoferLinuxMag'; 
%    "on obtient une liste des changements locaux par rapport aux packages spécifiés au dessus"
%    localChanges
%Il est possible d'afficher et de naviguer dans ces changements en utilisant le visualiseur standard de changement de Monticello en utilisant les méthodes « browseLocalChanges » et « browseRemoteChanges »
%Gofer new
%    squeaksource: 'GoferLinuxMag';
%    "on ajoute la dernière version de GoferLinuxMag"
%    package: 'GoferLinuxMag';
%    "on navigue dans les changements effectués sur le serveur"
%    browseRemoteChanges		
%/// Image : screenshot.png ///

\paragraph{Unload}

%Gofer permet de supprimer grâce à des scripts des packages de Pharo. La méthode « unload » permet de supprimer proprement les packages spécifiés et l'ensemble de leurs classes et méthodes contenus.
%Le script suivant permet de supprimer le package « GoferLinuxMag » de l'image Pharo:
%Gofer new
%    squeaksource: 'GoferLinuxMag';
%    package: 'GoferLinuxMag';
%    unload
%A noté qu'il n'est pas possible de supprimer Gofer par ce biais. La commande « Gofer gofer unload » ne fonctionne pas.

\paragraph{Fetch, push: two functions for offline synchronizing}

%Les deux méthodes « fetch » et « push » permettent à Gofer d'avoir le comportement d'un Git. Ce paragraphe montre l'une des fonctionnalités les plus importante de Gofer lorsque l'on travaille hors ligne.
%- « fetch » récupère les packages du serveur distant et remplit le répertoire d'installation local. Il ne les charge  pas dans l'image Pharo mais récupère uniquement les sources d'installations. Cela permet ensuite, hors ligne, d'installer les packages dans Pharo sans connexion internet.
%Gofer new
%    squeaksource: 'GoferLinuxMag';
%    package: 'GoferLinuxMag';
%    fetch
%Après avoir utilisé cette méthode, il est important lors du chargement du package de ne pas désactiver la recherche dans le répertoire local (méthodes disablePackageCache et enablePackageCache).
%- « push » effectue l'opération inverse: cette méthode prend les packages du répertoire local et les sauvegarde sur le répertoire distant. Après avoir sauvegardé les modifications dans le répertoire local via Monticello, il est possible à la prochaine connexion à Internet de sauvegarder les scripts d'installations sur le serveur distant en toute transparence.
%Gofer new
%    squeaksource: 'GoferLinuxMag';
%    package: 'GoferLinuxMag';
%    push
%Cela permet de constituer une base de données locale et de charger les packages hors connexion: le dossier local est toujours analysé avant le répertoire distant.
%Ainsi avec ces deux fonctions, il est facile de réaliser un script de synchronisation des répertoires local et distant:
%sync
% "synchroniser les répertoires local et distant"
% Gofer new
%     squeaksource: 'GoferLinuxMag';
%     package: 'GoferLinuxMag';
%     push
% Gofer new
%     squeaksource: 'GoferLinuxMag';
%     package: 'GoferLinuxMag';
%     fetch

\subsection{Automate Answers}

%Pharo dans son ensemble fournit des méthodes pratiques permettant d'avoir un système complètement maitrisé. Bien que le sujet ici ne soit pas Pharo dans son ensemble, la méthode « valueSupplyingAnswers: » nous intéresse particulièrement. Elle évalue un bloc avec une liste de questions/réponses qui peuvent être appelées durant l'exécution du script dans le bloc (entre crochets). Cela permet de gérer les valeurs à spécifier manuellement et d'y répondre automatiquement. L'exemple suivant montre 4 questions/réponses possibles dans un script.
%[ Gofer new
%	squeaksource: 'Seaside30';
%	package: 'LoadOrderTests';
%	load ]
%	valueSupplyingAnswers: {
%		{'Load Seaside'. True}.
%		{'SqueakSource User Name'. 'pharoUser'}.
%		{'SqueakSource Password'. 'pharoPwd'}.
%		{'Run tests'. false}.
%	}
%Ainsi, il est possible de complètement automatiser les scripts de chargement de vos applications.

\section{Conclusion}

%Nous vous avons présenté Gofer, un outil pour scripter la gestion des packages dans Pharo. Cet outil fonctionne avec l'ensemble des packages sur Pharo, il est donc très facile de créer un script permettant d'installer tous vos packages préférés. 
%Un package indispensable au bon apprentissage de l'environnement Pharo est le programme « ProfStef ». Vous pouvez le charger avec Gofer en exécutant le code suivant:
%Gofer it
%    squeaksource: 'MetacelloRepository';
%    package: 'ConfigurationOfProfStef';
%    load.
%((Smalltalk at: #ConfigurationOfProfStef) project version:'1.0')load.
%(Smalltalk at: #ProfStef) go.
%Amusez-vous bien !


%=================================================================

\ifx\wholebook\relax\else\end{document}\fi
%=================================================================

%-----------------------------------------------------------------

